# I solve dynamic connectivity _without disconnect_. Sites are `int`s from `0`
# to `count-1`, as are component ids.

pub struct UnionFind {
    # parent of `i`
    int* parent,
    # size of subtree rooted at `i`
    int* size,
    # the number of components.
    int count,
}

# I create a new `UnionFind` with `site_count` sites.
pub fn UnionFind__new(int site_count) {
    UnionFind* uf = malloc(sizeof(UnionFind));
    int* parent = malloc(site_count * sizeof(int));
    int* size = malloc(site_count * sizeof(int));
    int i = site_count;
    while i > 0 {
        i = i - 1;
        parent[i] = i;
        size[i] = 1;
    }
    uf.parent = parent;
    uf.size = size;
    uf.count = site_count;
    return uf;
}

# I drop the `UnionFind`.
pub fn UnionFind_drop(UnionFind* self) {
    free(self.parent);
    free(self.size);
    free(self);
}

# I unify sites `p` and `q`.
pub fn UnionFind_union(UnionFind* self, int p, int q) {
    p = self.find(p);
    q = self.find(q);
    if p == q { return; }

    int* parent = self.parent;
    int* size = self.size;
    int np = size[p];
    int nq = size[q];
    # put the smaller subtree under the larger
    if np < nq {
        parent[p] = q;
        size[q] = np + nq;
    } else {
        parent[q] = p;
        size[p] = np + nq;
    }

    self.count = self.count - 1;
}

# I return site `p`'s component identifier.
pub fn UnionFind_find(UnionFind* self, int p) {
    int* parent = self.parent;
    while parent[p] != p {
        # set `p`'s parent to its grandparent to reduce path length
        parent[p] = parent[parent[p]];
        p = parent[p];
    }
    return p;
}

# I return the size of `p`'s component.
pub fn UnionFind_size_of(UnionFind* self, int p) {
    p = self.find(p);
    int* size = self.size;
    return size[p];
}

# I return the number of components.
pub fn UnionFind_count(UnionFind* self) {
    return self.count;
}
