# I am a weighted di-graph data type, represented as an adjacency list. Node
# identifiers are always `int`. Edge weights are `void`, and can be either owned
# or unowned, defined at the _graph_ level. If owned, they must be directly
# `free`-able, without custom drop behavior.
#
# For an undirected graph, also add edge `v->u` for every edge `u->v` you add.
#
# For an unweighted di-graph, use `null` weights.
#
# ***NB:*** pointers are an `int` memory address, so can be used interchangeably
# as node identifiers. At least while Johann's typechecker lets you.

struct ArrayList;
struct HashMap;
struct Queue;

# I am a single edge in the graph, from `u` to `v`.
pub struct Edge {
    int u,
    int v,
    void weight,
}

pub fn Edge_u(Edge* self) { return self.u; }
pub fn Edge_v(Edge* self) { return self.v; }
pub fn Edge_weight(Edge* self) { return self.weight; }

fn Edge__new(int u, int v, void* weight) {
    Edge* e = malloc(sizeof(Edge));
    e.u = u;
    e.v = v;
    e.weight = weight;
    return e;
}

fn Edge_drop(Edge* self) {
    free(self);
}

fn Edge_drop_owned_weight(Edge* self) {
    free(self.weight);
    free(self);
}

# I am the type of `connected_components` iterator, returning `ArrayList`s of
# node ids.
pub struct ConnComps {
    Graph* g,
    ArrayList* ref, # MUST be the second slot
    Keys* keys,
    HashMap* visited,
}

fn ConnComps__new(Graph* g) {
    ConnComps* cc = malloc(sizeof(ConnComps));
    cc.g = g;
    cc.keys = g.nodes();
    cc.visited = HashMap__new(null, null);
    cc.ref = null;
    return cc;
}

pub fn ConnComps_drop(ConnComps* self) {
    ArrayList_drop(self.ref);
    free(self.keys);
    HashMap_drop(self.visited);
    free(self);
}

pub fn ConnComps_next(ConnComps* self) {
    ArrayList_drop(self.ref);
    self.ref = null;
    int* n;
    HashMap* visited = self.visited;
    while true {
        n = Keys_next(self.keys);
        if n == null { return null; }
        if visited.contains(*n) { again; }
        done;
    }
    Queue* q = Queue__new();
    q.push(*n);
    ArrayList* comp = ArrayList__new(10);
    self.ref = comp;
    while q.size() > 0 {
        int u = q.remove();
        if visited.put(u, 1) != null { again; }
        comp.push(u);

        ArrayList* edges = Graph_out_edges(self.g, u);
        if edges == null { done; }
        void* itr = ArrayList_iter(edges);
        while true {
            Edge** ep = Iter_next(itr);
            if ep == null { done; }
            Edge* e = *ep;
            q.push(e.v);
        }
        free(itr);
    }
    q.drop();
    # the ref is always at the second slot
    return self + sizeof(void*);
}

# I am a graph.
pub struct Graph {
    void* drop_edge,
    # Map<int, ArrayList<void>>
    HashMap* edges,
}

# I create a new graph with unowned edge weights. If they're allocations, you
# are responsible for ensuring their lifetime exceeds that of the graph.
pub fn Graph__new() {
    Graph* g = malloc(sizeof(Graph));
    g.drop_edge = &Edge_drop;
    g.edges = HashMap__new_owned(null, null, null, &ArrayList_drop);
    return g;
}

# I create a new graph with owned edge weights.
pub fn Graph__new_owned_weights() {
    Graph* g = Graph__new();
    g.drop_edge = &Edge_drop_owned_weight;
    return g;
}

# I drop a graph, all its internal structure, and if owned, the edge weights.
pub fn Graph_drop(Graph* self) {
    HashMap_drop(self.edges);
    free(self);
}

# I add a node to the graph, if it's not already known. If it is, I am a no-op.
pub fn Graph_add_node(Graph* self, int u) {
    if !HashMap_contains(self.edges, u) {
        HashMap_put(self.edges, u, null);
    }
}

# I add a new edge to the graph. Parallel edges are allowed. The graph will or
# will not take ownership of the passed weight, based on how it was constructed.
pub fn Graph_add_edge(Graph* self, int u, int v, void weight) {
    ArrayList* adj = self.out_edges(u);
    if adj == null {
        adj = ArrayList__new_owned(2, self.drop_edge);
        HashMap_put(self.edges, u, adj);
    }
    adj.push(Edge__new(u, v, weight));
}

# I return the out-degree of node `u`.
pub fn Graph_out_degree(Graph* self, int u) {
    ArrayList* adj = self.out_edges(u);
    if adj == null { return 0; }
    return adj.size();
}

# I return an `ArrayList` containing the out `Edge`s of node `u`. If it has
# zero out-edges, `null` will be returned (not an empty list).
pub fn Graph_out_edges(Graph* self, int u) {
    ArrayList* edges = HashMap_get(self.edges, u);
    if edges == null { return null; }
    if edges.size() == 0 { return null; }
    return edges;
}

# I return a `Keys` (from `HashMap`) which iterates over the graph's node ids.
pub fn Graph_nodes(Graph* self) {
    return HashMap_keys(self.edges);
}

# I return a `ConnComps` which iterates over the graph's connected components,
# returning each as an `ArrayList` of node ids.
pub fn Graph_connected_components(Graph* self) {
    return ConnComps__new(self);
}
