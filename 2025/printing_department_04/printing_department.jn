char ROLL = '@';
char OPEN = '.';

struct Map {
    int width,
    int height,
    char* grid,
    int** adj,
}

fn Map__new(int width, int height, char* grid, int** adj) {
    Map* m = malloc(sizeof(Map));
    m.width = width;
    m.height = height;
    m.grid = grid;
    m.adj = adj;
    return m;
}

fn Map_drop(Map* self) {
    free(self.grid);
    drop_adjacent(self.adj);
    free(self);
}

pub fn main() {
    Map* m = parse();
    aocd_verify_a("%d", count_accessible(m));
    int removed = 0;
    char* grid = m.grid;
    while true {
        ArrayList* accessible = get_accessible(m);
        if accessible.size() == 0 {
            accessible.drop();
            done;
        }
        while accessible.size() > 0 {
            int t = accessible.pop();
            removed = removed + 1;
            if grid[t] != ROLL {
                eprintf("tile %d is accessible, but isn't a roll?!\n", t);
                exit(4);
            }
            grid[t] = OPEN;
        }
        accessible.drop();
    }
    aocd_verify_b("%d", removed);
    m.drop();
}

fn count_accessible(Map* m) {
    ArrayList* accessible = get_accessible(m);
    int result = accessible.size();
    accessible.drop();
    return result;
}

fn get_accessible(Map* m) {
    ArrayList* rolls = ArrayList__new(8);
    char* grid = m.grid;
    int** adj = m.adj;
    int t = m.width * m.height;
    while t > 0 {
        t = t - 1;
        if grid[t] != ROLL { again; }
        if has_four_neighbors(grid, t, adj[t]) { again; }
        rolls.push(t);
    }
    return rolls;
}

fn has_four_neighbors(char* grid, int t, int* adj) {
    ArrayList* ns = get_four_rolls_adjacent_to(grid, t, adj);
    bool result = ns.size() >= 4;
    ns.drop();
    return result;
}

fn get_four_rolls_adjacent_to(char* grid, int t, int* adj) {
    ArrayList* rolls = ArrayList__new(4);
    int n = adj;
    while *n >= 0 {
        char c = grid[*n];
        if c == ROLL {
            rolls.push(*n);
            if rolls.size() == 4 {
                return rolls;
            }
        }
        n = n + sizeof(int);
    }
    return rolls;
}

fn parse() {
    char* line = read_line();
    int width = strlen(line);
    StringBuilder* sb = StringBuilder__new(width * width + 1);
    sb.push_str(line);
    free(line);
    int height = 1;
    while !iseof() {
        line = read_line();
        sb.push_str(line);
        free(line);
        height = height + 1;
    }

    return Map__new(width,
                    height,
                    sb.into_chars(),
                    build_eight_way_adjacent(width, height));
}
