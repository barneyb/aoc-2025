struct Tile {
    int x,
    int y,
}

fn Tile__new(int x, int y) {
    Tile* t = malloc(sizeof(Tile));
    t.x = x;
    t.y = y;
    return t;
}

fn Tile_area(Tile* self, Tile* other) {
    int dx = abs(self.x - other.x) + 1;
    int dy = abs(self.y - other.y) + 1;
    return dx * dy;
}

bool SVG = false;
bool PART_B = false;

pub fn main(int argc, char** argv) {
    HashMap* opts = get_opts(argc, argv);
    SVG = opts.contains("--svg");
    PART_B = !opts.contains("--no-part-b");
    opts.drop();

    aocd_run(&solve);
}

fn solve(char** ans_a, char** ans_b) {
    ArrayList* tiles = read_input();

    if SVG {
        emit_svg(tiles, PART_B);
        tiles.drop();
        return;
    }

    int area = largest_rectangle(tiles);
    printf("Largest Rectangle: %d\n", area);
    *ans_a = itoa(area);

    if PART_B {
        area = largest_redgreen_rectangle(tiles);
        printf("Largest Colored Rectangle: %d\n", area);
        *ans_b = itoa(area);
    } else {
        printf("Skipping part b\n");
    }

    tiles.drop();
}

fn largest_redgreen_rectangle(ArrayList* tiles) {
    int largest = 0;
    ArrayList* anchors = find_anchors(tiles);
    Tile* B = anchors.pop();
    Tile* A = anchors.pop();
    anchors.drop();
    # Identified by browser-inspecting the rendered SVG (at 1/100 scale), which
    # mapped unambiguously to an input tile (at full-scale). `b` is correctly
    # identified below.
    Tile* a = Tile__new(4386, 33943);
    Tile* b = find_b(tiles, B);
    int area_a = A.area(a);
    int area_b = B.area(b);
    printf("Rect A: (%d, %d) to (%d, %d) w/ area %d\n", A.x, A.y, a.x, a.y, area_a);
    printf("Rect B: (%d, %d) to (%d, %d) w/ area %d\n", B.x, B.y, b.x, b.y, area_b);

    free(a);
    return max(area_a, area_b);
}

fn find_anchors(ArrayList* tiles) {
    Tile* prev = tiles.get(0);
    Tile* t = tiles.get(1);
    if prev.x < t.x || prev.y > t.y {
        eprintf("Solver expects tiles are listed clockwise from three o'clock\n");
        exit(5);
    }
    int i = tiles.size();
    ArrayList* lines = ArrayList__new(4);
    while i > 0 {
        i = i - 1;
        t = tiles.get(i);
        int dx = abs(prev.x - t.x);
        if dx > 10000 {
            int halfway = tiles.size() / 2;
            if i < halfway - 2 || i > halfway + 2 {
                eprintf("Solver assumes dividers are roughly opposite the first tile\n");
                exit(5);
            }
            eprintf("horizontal line from (%d,%d) to (%d,%d) at %d & %d\n", t.x, t.y, prev.x, prev.y, i, i + 1);
            lines.push(t);
            lines.push(prev);
        }
        prev = t;
    }
    if lines.size() != 4 {
        eprintf("Solver assumes two horizontal 'dividing' lines, but didn't find them\n");
        exit(5);
    }
    # now get A/B
    Tile* a = lines.pop();
    Tile* b = lines.pop();
    Tile* c = lines.pop();
    Tile* d = lines.pop();
    if a.x == d.x {
        if a.x < b.x {
            eprintf("Solver assumes wormhole opens left, but it doesn't\n");
            exit(5);
        }
        b = d;
    } else if b.x == c.x {
        if c.x < d.x {
            eprintf("Solver assumes wormhole opens left, but it doesn't\n");
            exit(5);
        }
        a = c;
    } else {
        eprintf("Solver assumes dividers are separated by a single vertical segment, but aren't\n");
        exit(5);
    }
    # and ensure they're in order
    if a.y < b.y {
        lines.push(a);
        lines.push(b);
    } else {
        lines.push(b);
        lines.push(a);
    }
    return lines;
}

fn emit_svg(ArrayList* tiles, bool part_b) {
    Svg* svg = Svg__new(1000, 1000);
    Tile* prev = tiles.get(0);
    int i = tiles.size();
    if part_b {
        while i > 0 {
            i = i - 1;
            Tile* t = tiles.get(i);
            svg.line(prev.x / 100, prev.y / 100, t.x / 100, t.y / 100, "stroke:green");
            prev = t;
        }
    }
    i = tiles.size();
    while i > 0 {
        i = i - 1;
        t = tiles.get(i);
        svg.rect(t.x / 100-1, t.y / 100-1, 2, 2, "fill:red");
        if part_b && i % 25 == 0 {
            char* s = itoa(i);
            svg.text(t.x / 100+1, t.y / 100+1, "fill:gray", s);
            free(s);
        }
    }

    if !part_b {
        ArrayList* corners = find_corners(tiles);
        Tile* b = corners.pop();
        svg.text(b.x / 100, b.y / 100, null, "B");
        Tile* a = corners.pop();
        svg.text(a.x / 100, a.y / 100, null, "A");
        Tile* pos = Tile__new(min(a.x, b.x) / 100,
                              min(a.y, b.y) / 100);
        Tile* dim = Tile__new(abs(b.x - a.x) / 100 + 1,
                              abs(b.y - a.y) / 100 + 1);
        corners.drop();
        svg.rect(pos.x, pos.y, dim.x, dim.y, "fill:lightgray;opacity:0.5");
        s = itoa(a.area(b));
        svg.text(pos.x + 2, pos.y + dim.y - 2, null, s);
        free(pos);
        free(dim);
        free(s);
        svg.drop();
        return;
    }

    ArrayList* anchors = find_anchors(tiles);
    # Identified by browser-inspecting the rendered SVG (at 1/100 scale), which
    # mapped unambiguously to an input tile (at full-scale). `b` is correctly
    # identified below.
    a = Tile__new(4386, 33943); # 43, 339

    t = anchors.pop();
    b = find_b(tiles, t);
    char* style_limits = "stroke: gray; stroke-width: hairline; stroke-dasharray:2 3;";
    svg.line(t.x / 100, t.y / 100, t.x / 100, 1000, style_limits);
    svg.line(t.x / 100, 681, 0, 681, style_limits);
    char* style_bounds = "stroke:blue; stroke-dasharray:2 3";
    svg.line(b.x / 100, b.y / 100, 1000, b.y / 100, style_bounds);
    svg.line(b.x / 100, b.y / 100, b.x / 100, t.y / 100, style_bounds);
    s = itoa(t.area(b));
    char* style_area = "fill:blue";
    svg.text(b.x / 100 + 2, b.y / 100 - 2, style_area, s);
    free(s);

    t = anchors.pop();
    svg.line(t.x / 100, t.y / 100, t.x / 100, 0, style_limits);
    svg.line(t.x / 100, 335, 0, 335, style_limits);
    svg.line(a.x / 100, a.y / 100, 1000, a.y / 100, style_bounds);
    svg.line(a.x / 100, a.y / 100, a.x / 100, t.y / 100, style_bounds);
    s = itoa(t.area(a));
    svg.text(a.x / 100 + 2, t.y / 100 - 2, style_area, s);
    free(s);

    free(a);
    anchors.drop();
    svg.drop();
}

fn find_b(ArrayList* tiles, Tile* B) {
    # First, find a tile (B') which is too far left and get its y. This should
    # use an index on x, and get the floor B.x.
    Tile* t;
    int i = 0;
    while true {
        t = tiles.get(i);
        if t.x < B.x {
            eprintf("B' is (%d, %d)\n", t.x, t.y);
            done;
        }
        i = i + 1;
    }
    int max_y = t.y;

    # Now, go to the other side and find the rightmost tile (b) at or above max
    # y. This needs an index on y/x, for floor of B.y/B'.x.
    int min_x = 0;
    i = tiles.size() / 2;
    while true {
        t = tiles.get(i);
        if t.x < B.x {
            if t.y >= max_y { done; }
            min_x = max(min_x, t.x);
        }
        i = i - 1;
    }

    # Finally, reverse direction and find the first tile which satisfies both.
    while true {
        t = tiles.get(i);
        if t.x >= min_x && t.y <= max_y {
            eprintf("b is (%d, %d)\n", t.x, t.y);
            return t;
        }
        i = i + 1;
    }
}

fn largest_rectangle(ArrayList* tiles) {
    ArrayList* corners = find_corners(tiles);
    Tile* b = corners.pop();
    Tile* a = corners.pop();
    corners.drop();
    int area = a.area(b);
    printf("Rect: (%d, %d) to (%d, %d) w/ area %d\n", a.x, a.y, b.x, b.y, area);
    return area;
}

fn find_corners(ArrayList* tiles) {
    int largest = 0;
    Tile* t1 = null;
    Tile* t2 = null;
    int i = tiles.size();
    while i > 0 {
        i = i - 1;
        Tile* t = tiles.get(i);
        int j = i;
        while j > 0 {
            j = j - 1;
            int a = t.area(tiles.get(j));
            if a > largest {
                largest = a;
                t1 = t;
                t2 = tiles.get(j);
            }
        }
    }
    ArrayList* ts = ArrayList__new(2);
    ts.push(t1);
    ts.push(t2);
    return ts;
}

fn read_input() {
    ArrayList* tiles = ArrayList__new_owned(10, &free);
    while !iseof() {
        tiles.push(read_tile());
    }
    return tiles;
}

fn read_tile() {
    int x = read_int();
    getchar(); # comma
    int y = read_int();
    getchar(); # newline
    return Tile__new(x, y);
}

fn read_int() {
    int i = 0;
    while isdigit(peekchar()) {
        i = i * 10 + (getchar() - '0');
    }
    return i;
}
