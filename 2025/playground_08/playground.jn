struct Box {
    int x,
    int y,
    int z,
}

fn Box__new(int x, int y, int z) {
    Box* b = malloc(sizeof(Box));
    b.x = x;
    b.y = y;
    b.z = z;
    return b;
}

fn Box_dist_squared(Box* self, Box* other) {
    int dx = self.x - other.x;
    int dy = self.y - other.y;
    int dz = self.z - other.z;
    return dx * dx + dy * dy + dz * dz;
}

struct Lights {
    int len,
    int i,
    int j,
}

fn Lights_len(Lights* self) { return self.len; }

fn Lights__new(int i, int j, int len) {
    Lights* l = malloc(sizeof(Lights));
    l.i = i;
    l.j = j;
    l.len = len;
    return l;
}

fn Lights_cmp(Lights* a, Lights* b) {
    return a.len - b.len;
}

fn intcmp_rev(int a, int b) { return b - a; }

pub fn main(int argc, char** argv) {
    HashMap* opts = get_opts(argc, argv);
    int conn_count = 1000;
    if opts.contains("-n") {
        conn_count = atoi(opts.get("-n"));
    }
    opts.drop();

    # I own the `Box`es.
    ArrayList* boxes = ArrayList__new_owned(conn_count, &free);
    while !iseof() { boxes.push(read_box()); }

    aocd_verify_a("%d", part_a(conn_count, boxes));

    boxes.drop();
}

fn part_a(int conn_count, ArrayList* boxes) {
    # the N shortest strings of lights
    PQ* pq = PQ__new(conn_count, &Lights_cmp);
    int i = boxes.size();
    while i > 0 {
        i = i - 1;
        Box* b = boxes.get(i);
        int j = boxes.size();
        while true {
            j = j - 1;
            if i == j { done; }
            int d = b.dist_squared(boxes.get(j));
            # instantiation is expensive, so do a pre-check
            Lights** lp = pq.peek();
            if lp == null || Lights_len(*lp) > d {
                free(pq.force_push(Lights__new(i, j, d)));
            }
        }
    }

    # This is sorta silly, but it's correct
    Graph* project = Graph__new();
    while pq.size() > 0 {
        Lights* l = pq.pop();
        project.add_edge(l.i, l.j, null);
        project.add_edge(l.j, l.i, null);
        free(l);
    }
    pq.drop();

    pq = PQ__new(3, &intcmp_rev);
    ConnComps* ccs = project.connected_components();
    while true {
        ArrayList** ptr = ccs.next();
        if ptr == null { done; }
        pq.force_push(ArrayList_size(*ptr));
    }
    ccs.drop();
    int answer = 1;
    printf("Largest circuits :");
    while pq.size() > 0 {
        i = pq.pop();
        printf(" %d", i);
        answer = answer * i;
    }
    printf("\nMultiply to      : %d\n", answer);
    pq.drop();
    project.drop();
    return answer;
}

fn read_box() {
    int x = read_int();
    getchar(); # comma
    int y = read_int();
    getchar(); # comma
    int z = read_int();
    getchar(); # newline
    return Box__new(x, y, z);
}

fn read_int() {
    int i = 0;
    while isdigit(peekchar()) {
        i = i * 10 + (getchar() - '0');
    }
    return i;
}
