struct Box {
    int x,
    int y,
    int z,
}

fn Box__new(int x, int y, int z) {
    Box* b = malloc(sizeof(Box));
    b.x = x;
    b.y = y;
    b.z = z;
    return b;
}

fn Box_dist_squared(Box* self, Box* other) {
    int dx = self.x - other.x;
    int dy = self.y - other.y;
    int dz = self.z - other.z;
    return dx * dx + dy * dy + dz * dz;
}

struct Lights {
    int len,
    int i,
    int j,
}

fn Lights_len(Lights* self) { return self.len; }

fn Lights__new(int i, int j, int len) {
    Lights* l = malloc(sizeof(Lights));
    l.i = i;
    l.j = j;
    l.len = len;
    return l;
}

fn Lights_cmp(Lights* a, Lights* b) {
    return a.len - b.len;
}

fn intcmp_rev(int a, int b) { return b - a; }

pub fn main(int argc, char** argv) {
    HashMap* opts = get_opts(argc, argv);
    int conn_count = 1000;
    if opts.contains("-n") {
        conn_count = atoi(opts.get("-n"));
    }
    bool do_svg = opts.contains("--svg");
    opts.drop();

    # I own the `Box`es.
    ArrayList* boxes = ArrayList__new_owned(conn_count, &free);
    while !iseof() { boxes.push(read_box()); }

    if do_svg {
        part_b(boxes, do_svg);
    } else {
        aocd_verify_a("%d", part_a(conn_count, boxes));
        aocd_verify_b("%d", part_b(boxes, do_svg));
    }

    boxes.drop();
}

fn part_a(int conn_count, ArrayList* boxes) {
    # the N shortest strings of lights
    PQ* pq = PQ__new(conn_count, &Lights_cmp);
    int i = boxes.size();
    while i > 0 {
        i = i - 1;
        Box* b = boxes.get(i);
        int j = boxes.size();
        while true {
            j = j - 1;
            if i == j { done; }
            int d = b.dist_squared(boxes.get(j));
            # instantiation is expensive, so do a pre-check
            Lights** lp = pq.peek();
            if lp == null || Lights_len(*lp) > d {
                free(pq.force_push(Lights__new(i, j, d)));
            }
        }
    }

    # from the shortest, connect N
    UnionFind* uf = UnionFind__new(boxes.size());
    while pq.size() > 0 {
        Lights* l = pq.pop();
        uf.union(l.i, l.j);
        free(l);
    }
    pq.drop();

    # part A is ready!
    pq = PQ__new(3, &intcmp_rev);
    i = boxes.size();
    while i > 0 {
        i = i - 1;
        if uf.find(i) == i {
            pq.force_push(uf.size_of(i));
        }
    }
    uf.drop();

    int answer = 1;
    printf("Largest circuits :");
    while pq.size() > 0 {
        i = pq.pop();
        printf(" %d", i);
        answer = answer * i;
    }
    printf("\nMultiply to      : %d\n", answer);
    pq.drop();
    return answer;
}

# Construct the minimum spanning tree. If we'd connected boxes in proximity
# order until fully connected, the longest edge in the MST is the edge we want.
fn part_b(ArrayList* boxes, bool do_svg) {
    # "set" of boxes without power
    HashMap* unpowered = HashMap__new(null, null);
    Svg* svg = null;
    int f = 2;
    int off = 500;
    if do_svg {
        svg = Svg__new(1000, 1000);
        if boxes.size() > 100 { f = 200; }
    }
    # shortest distance to an unpowered box
    int* best_dist = malloc(boxes.size() * sizeof(int));
    # best lights to reach an unpowered box
    Lights** best_lights = calloc(boxes.size(), sizeof(int));
    int i = boxes.size();
    while i > 0 {
        i = i - 1;
        best_dist[i] = MAX_INTEGER;
        unpowered.put(i, i);
    }

    # deliver power to box zero
    best_dist[0] = 0;
    if do_svg {
        add_power(svg, f, off, boxes.get(0));
    }

    while unpowered.size() > 0 {
        # find unpowered box with with minimum distance from any powered one
        int min_dist = MAX_INTEGER;
        i = -1;
        Keys* keys = unpowered.keys();
        while true {
            void* ptr = keys.next();
            if ptr == null { done; }
            int u = *ptr;
            if best_dist[u] < min_dist {
                min_dist = best_dist[u];
                i = u;
            }
        }
        keys.drop();
        if i < 0 {
            eprintf("didn't find a next box?!\n");
            exit(1);
        }

        # give it power
        unpowered.delete(i);
        Box* b = boxes.get(i);
        if do_svg && i > 0 {
            Lights* ls = best_lights[i];
            add_lights(svg, f, off, boxes.get(ls.i), b);
        }

        # for each unpowered box, see if the latest box brought power closer
        keys = unpowered.keys();
        while true {
            ptr = keys.next();
            if ptr == null { done; }
            int j = *ptr;
            int d = b.dist_squared(boxes.get(j));
            if d >= best_dist[j] { again; }
            best_dist[j] = d;
            free(best_lights[j]);
            best_lights[j] = Lights__new(i, j, d);
        }
        keys.drop();
    }

    # find the longest string of lights in the MST
    int max_len = MIN_INTEGER;
    ls = null;
    i = boxes.size();
    while i > 1 { # box zero was a gimme
        i = i - 1;
        Lights* l = best_lights[i];
        if l == null {
            eprintf("Didn't reach box %d?!\n", i);
            exit(5);
        }
        if ls == null || ls.len < l.len {
            free(ls);
            ls = l;
        } else {
            free(l);
        }
    }

    free(best_lights);
    free(best_dist);
    unpowered.drop();

    b = boxes.get(ls.i);
    if !do_svg { printf("                 : (%d, %d, %d)\n", b.x, b.y, b.z); }
    int answer = b.x;
    b = boxes.get(ls.j);
    if !do_svg { printf("                 : (%d, %d, %d)\n", b.x, b.y, b.z); }
    answer = answer * b.x;
    if !do_svg { printf("Multiply X's     : %d\n", answer); }
    free(ls);
    if do_svg { svg.drop(); }
    return answer;
}

fn add_lights(Svg* svg, int f, int off, Box* a, Box* b) {
    add_power(svg, f, off, b);
    svg.line(a.x / f      , a.y / f      , b.x / f      , b.y / f      , "stroke:green");
    svg.line(a.y / f + off, a.z / f      , b.y / f + off, b.z / f      , "stroke:green");
    svg.line(a.x / f      , a.z / f + off, b.x / f      , b.z / f + off, "stroke:green");
}

fn add_power(Svg* svg, int f, int off, Box* b) {
    svg.rect(b.x / f - 1      , b.y / f - 1      , 3, 3, "fill:red");
    svg.rect(b.y / f - 1 + off, b.z / f - 1      , 3, 3, "fill:red");
    svg.rect(b.x / f - 1      , b.z / f - 1 + off, 3, 3, "fill:red");
}

fn read_box() {
    int x = read_int();
    getchar(); # comma
    int y = read_int();
    getchar(); # comma
    int z = read_int();
    getchar(); # newline
    return Box__new(x, y, z);
}

fn read_int() {
    int i = 0;
    while isdigit(peekchar()) {
        i = i * 10 + (getchar() - '0');
    }
    return i;
}
