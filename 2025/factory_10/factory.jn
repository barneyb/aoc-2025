struct Machine {
    int id,
    int light_count,
    int light_state,
    ArrayList* buttons,
    ArrayList* jbuttons,
    ArrayList* joltages,
}

fn Machine__new(int id, int light_count, int light_state) {
    Machine* m = malloc(sizeof(Machine));
#    printf("machine #%d w/ %d lights: %4x\n", id, light_count, light_state);
    m.id = id;
    m.light_count = light_count;
    m.light_state = light_state;
    m.buttons = ArrayList__new(10);
    m.jbuttons = ArrayList__new_owned(10, &free);
    m.joltages = ArrayList__new(10);
    return m;
}

fn Machine_drop(Machine* self) {
    ArrayList_drop(self.buttons);
    ArrayList_drop(self.jbuttons);
    ArrayList_drop(self.joltages);
    free(self);
}

fn Machine_add_button(Machine* self, int btn) {
#    printf("  btn %4x /", btn);
    ArrayList_push(self.buttons, btn);
    int* arr = malloc(self.light_count * sizeof(int));
    int i = self.light_count;
    while i > 0 {
        i = i - 1;
        arr[i] = btn & 0x1;
        btn = btn >> 1;
    }
    ArrayList_push(self.jbuttons, arr);
#    i = 0;
#    while i < self.light_count {
#        printf(" %d", arr[i]);
#        i = i + 1;
#    }
#    puts("");
}

fn Machine_add_joltage(Machine* self, int j) {
#    printf("  joltage %d\n", j);
    ArrayList_push(self.joltages, j);
}

struct St {
    int steps,
    int value,
}

fn St__new(int steps, int value) {
    St* s = malloc(sizeof(St));
    s.steps = steps;
    s.value = value;
    return s;
}

fn Machine_do_lights(Machine* self) {
    ArrayList* buttons = self.buttons;
    HashMap* visited = HashMap__new(null, null);
    Queue* q = Queue__new_owned(&free);
    q.push(St__new(0, 0));
    while q.size() > 0 {
        St* st = q.remove();
        if visited.put(st.value, 1) == 1 {
            free(st);
            again;
        }
        int i = buttons.size();
        while i > 0 {
            i = i - 1;
            int btn = buttons.get(i);
            int next = btn ^ st.value;
            if next == self.light_state {
                q.drop();
                visited.drop();
                int n = st.steps + 1;
                free(st);
                return n;
            }
            if !visited.contains(next) {
                q.push(St__new(st.steps + 1, next));
            }
        }
        free(st);
    }
    eprintf("failed to configure machine #%d's lights\n", self.id);
    exit(1);
}

fn Machine_do_joltages(Machine* self) {
    int* js = ArrayList_into_array(self.joltages);
    self.joltages = null;

    # After doing some reading, this is the right line of inquiry. My math is
    # too weak to describe it correctly, let alone implement all the lower
    # layers correctly and efficiently. But doing some elimination and then
    # treating it as an optimization problem in a greatly reduced domain seems
    # good. Lotta internet folk used various constraint solvers.
    #
    # The "Simplex Method" seems to be a specialization that sorta does both
    # halves, once you get a specifically constructed matrix. Johann doesn't
    # even support two-dimensional arrays, let alone matrices. And unclear it
    # it'd work without reals (only ints).
    #
    # Problems for another day.

    ArrayList* buttons = self.jbuttons;
    int i = buttons.size();
    while i > 0 {
        i = i - 1;
        int* btn = buttons.get(i);
        int f = self.vec_div(js, btn);
        printf("  button %d (%x) fits %d times\n", i, ArrayList_get(self.buttons, i), f);
        if f == 0 {
            free(btn);
            if i == buttons.size() - 1 {
                buttons.pop();
            } else {
                buttons.set(i, buttons.pop());
            }
            puts("    removed!");
        }
    }
    ArrayList* sets = ArrayList__new_owned(self.light_count, &free);
    int c = 0;
    while c < self.light_count {
        if js[c] == 0 { c = c + 1; again; }
        StringBuilder* sb = StringBuilder__new(self.light_count + 1);
        i = 0;
        while i < buttons.size() {
            btn = buttons.get(i);
            if btn[c] == 1 {
                sb.push('a' + i);
            }
            i = i + 1;
        }
        char* set = sb.into_chars();
        sets.push(set);
        if strlen(set) == 1 {
            printf("  fix on %d: %c = %d.\n", c, set[0], js[c]);
        } else if sb.length() > 0 {
            printf("  constraint at %d: %s = %d.\n", c, set, js[c]);
        }
        c = c + 1;
    }
    sets.drop();

    free(js);
    return 1;
#    eprintf("failed to configure machine #%d's joltages\n", self.id);
#    exit(1);
}

fn Machine_do_joltages_internal(
    Machine* self,
    ArrayList* buttons,
    int* goal,
    int avail
) {
    if self.is_zero_vec(goal) { return 0; }
    if avail == 0 { return MAX_INTEGER; }
    if buttons.size() == 0 { return MAX_INTEGER; }

    int* btn = buttons.peek();
    int i = min(avail, self.vec_div(goal, btn));

    # this is our last hope
    if buttons.size() == 1 {
        int* next = self.vec_msub(goal, i, btn);
        if self.is_zero_vec(next) {
            avail = i;
        }
        free(next);
        return avail;
    }

    # try every multiple of this level that fits and recurse each one
    buttons.pop();
#    printf(" %d repeats, w/ %d more levels and %d avail\n", i, buttons.size(), avail);
    while i > 0 {
        next = self.vec_msub(goal, i, btn);
        int n = self.do_joltages_internal(
            buttons,
            next,
            avail - i);
        if n < avail - i {
            avail = n + i;
        }
        free(next);
        i = i - 1;
    }

    # try without anything from this level
    n = self.do_joltages_internal(
        buttons,
        goal,
        avail);
    if n < avail { avail = n; }

    buttons.push(btn);
    return avail;
}

# subtract `n` copies of `ys` from `xs`
fn Machine_vec_msub(Machine* self, int* xs, int n, int* ys) {
    int bytes = self.light_count * sizeof(int);
    int* next = malloc(bytes);
    memcpy(next, xs, bytes);
    if n == 0 { return next; }

    int i = self.light_count;
    while i > 0 {
        i = i - 1;
        next[i] = next[i] - n * ys[i];
    }
    return next;
}

# return the largest multiplier for `ys` that wouldn't exceed `xs`
fn Machine_vec_div(Machine* self, int* xs, int* ys) {
    int quot = MAX_INTEGER;
    int i = self.light_count;
    while i > 0 {
        i = i - 1;
        if ys[i] != 0 {
            quot = min(quot, xs[i] / ys[i]);
        }
    }
    if quot == MAX_INTEGER { quot = 0; }
    return quot;
}

fn Machine_is_zero_vec(Machine* self, int* vec) {
    int i = self.light_count;
    while i > 0 {
        i = i - 1;
        if vec[i] != 0 {
            return false;
        }
    }
    return true;
}

struct Counts {
    int light,
    int joltage,
}

pub fn main() {
    ArrayList* machines = ArrayList__new_owned(10, &Machine_drop);
    int id = 0;
    while !iseof() {
        id = id + 1;
        machines.push(read_machine(id));
    }
    Counts* cs = configure_machines(machines);
    printf("For Lights  : %d\n", cs.light);
    aocd_verify_a("%d", cs.light);
    printf("For Joltages: %d\n", cs.joltage);
#    aocd_verify_b("%d", cs.joltage);
    free(cs);
    machines.drop();
}

fn configure_machines(ArrayList* machines) {
    Counts* cs = malloc(sizeof(Counts));
    cs.light = 0;
    cs.joltage = 0;
    int i = machines.size();
    while i > 0 {
        i = i - 1;
        Machine* m = machines.get(i);
        cs.light = cs.light + m.do_lights();
        int p = m.do_joltages();
        printf("Machine #%d took %d presses to set joltages\n", m.id, p);
        cs.joltage = cs.joltage + p;
    }
    return cs;
}

fn read_machine(int id) {
    if getchar() != '[' { exit(23); }
    int lights = 0;
    int len = 0;
    while peekchar() != ']' {
        lights = lights << 1;
        len = len + 1;
        if getchar() == '#' {
            lights = lights + 1;
        }
    }
    Machine* m = Machine__new(id, len, lights);
    if getchar() != ']' { exit(24); }
    if getchar() != ' ' { exit(25); }
    while peekchar() == '(' {
        getchar();
        int btn = 0;
        while true {
            int n = read_int();
            n = 1 << (len - n - 1);
            btn = btn | n;
            if getchar() != ',' { done; }
        }
        m.add_button(btn);
        if getchar() != ' ' { exit(26); }
    }
    if getchar() != '{' { exit(27); }
    while peekchar() != '}' {
        if peekchar() == ',' {
            getchar();
        }
        m.add_joltage(read_int());
    }
    if getchar() != '}' { exit(28); }
    if getchar() != 0xa { exit(29); }
    return m;
}

fn read_int() {
    int i = 0;
    while isdigit(peekchar()) {
        i = i * 10 + (getchar() - '0');
    }
    return i;
}
