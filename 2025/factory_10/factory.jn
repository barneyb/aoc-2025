# four expressions of the same fact: 2 bytes of buttons, then 6 of joltages
int BUTTONS_BITS  = 2 * 8;
int JOLTAGE_BITS  = 6 * 8;
int BUTTONS_MASK  = 0xffff_0000_0000_0000;
int JOLTAGE_MASK  = 0x0000_ffff_ffff_ffff;
int OVERFLOW_MASK = 0x0000_8000_0000_0000;

struct Machine {
    int id,
    int light_count,
    int light_state,
    ArrayList* buttons,
    ArrayList* joltages,
}

fn Machine__new(int id, int light_count, int light_state) {
    Machine* m = malloc(sizeof(Machine));
#    printf("machine #%d w/ %d lights: %4x\n", id, light_count, light_state);
    m.id = id;
    m.light_count = light_count;
    m.light_state = light_state;
    m.buttons = ArrayList__new(10);
    m.joltages = ArrayList__new(10);
    return m;
}

fn Machine_drop(Machine* self) {
    ArrayList_drop(self.buttons);
    ArrayList_drop(self.joltages);
    free(self);
}

fn Machine_add_button(Machine* self, int btn) {
#    printf("  btn %4x\n", btn);
    ArrayList_push(self.buttons, btn);
}

fn Machine_add_joltage(Machine* self, int j) {
#    printf("  joltage %d\n", j);
    ArrayList_push(self.joltages, j);
}

struct St {
    int steps,
    int value,
}

fn St__new(int steps, int value) {
    St* s = malloc(sizeof(St));
    s.steps = steps;
    s.value = value;
    return s;
}

fn Machine_do_lights(Machine* self) {
    ArrayList* buttons = self.buttons;
    HashMap* visited = HashMap__new(null, null);
    Queue* q = Queue__new_owned(&free);
    q.push(St__new(0, 0));
    while q.size() > 0 {
        St* st = q.remove();
        if visited.put(st.value, 1) == 1 {
            free(st);
            again;
        }
        int i = buttons.size();
        while i > 0 {
            i = i - 1;
            int btn = buttons.get(i);
            int next = btn ^ st.value;
            if next == self.light_state {
                q.drop();
                visited.drop();
                int n = st.steps + 1;
                free(st);
                return n;
            }
            if !visited.contains(next) {
                q.push(St__new(st.steps + 1, next));
            }
        }
        free(st);
    }
    eprintf("failed to configure machine #%d's lights\n", self.id);
    exit(1);
}

fn intcmp_rev(int a, int b) { return b - a; }

fn Machine_do_joltages(Machine* self) {
    ArrayList* rows = self.build_rows();
    int presses = self.do_jrows(rows, 0);
    rows.drop();
    return presses;
}

fn ArrayList_clone(ArrayList* self) { # todo: jstdlib
    int len = self.size();
    ArrayList* c = ArrayList__new(len); # todo: ownership?
    int i = 0;
    while i < len {
        c.push(self.get(i));
        i = i + 1;
    }
    return c;
}

fn Machine_do_jrows(Machine* self, ArrayList* rows, int depth) {
    printf("do %d jrows at depth %d\n", rows.size(), depth);
#    if !self.eliminate(rows) {
#        puts("something's screwy");
#        return MAX_INTEGER;
#    }
#    puts("eliminated to:");
    self.print_rows(rows);
    return 4;

    if depth > 10 {
        printf("OVER DEEP: %d!!\n", depth);
        exit(6);
    }

    if self.is_fully_reduced(rows) {
        int r = rows.size();
        int sum = 0;
        while r > 0 {
            r = r - 1;
            sum = sum + (rows.get(r) & JOLTAGE_MASK);
        }
        return sum;
    }

    # sanity check
    int button_count = ArrayList_size(self.buttons);
    if rows.size() > button_count {
        printf("Found %d rows, for %d columns?!\n", rows.size(), button_count);
        self.print_rows(rows);
        exit(4);
    }

    # first, find a column w/out a leading one
    int bit = self.leftmost_orphan_bit(rows);

    char* intro = "try";
    int best = MAX_INTEGER;
    while bit > JOLTAGE_MASK {
        # find the smallest answer that column influences
        int ans = self.min_answer_with_bit(rows, bit);
        while ans >= 0 {
            ArrayList* next = rows.clone();
            printf("  %s w/:\n", intro);
            intro = "then";
            self.print_row(bit | ans);
            next.push(bit | ans);
            int n = self.do_jrows(next, depth + 1);
            if n < best {
                best = n;
                printf("    new best: %d!\n", best);
            }
            next.drop();
            ans = ans - 1;
        }
        if best < MAX_INTEGER {
            # progress was made!
            done;
        }
        bit = bit >> 1;
    }
    if best == MAX_INTEGER {
        printf("From these rows:\n");
        self.print_rows(rows);
        printf("failed to reach any solutions?!\n");
        exit(5);
    }
    return best;
}

# Return whether the "left" of the matrix is the identity matrix in reduced row
# echelon form (i.e., a unique solution).
fn Machine_is_fully_reduced(Machine* self, ArrayList* rows) {
    int button_count = ArrayList_size(self.buttons);
    if rows.size() != button_count { return false; }
    int shift = JOLTAGE_BITS + button_count - 1;
    int bit = 1 << shift;
    int i = 0;
    while i < rows.size() {
        if (rows.get(i) & BUTTONS_MASK) != bit {
#            printf("GONK! row %d is\n", i);
#            self.print_row(rows.get(i) & BUTTONS_MASK);
#            printf("but expected:\n");
#            self.print_row(bit);
            return false;
        }
        i = i + 1;
        bit = bit >> 1;
    }
    return true;
}

fn Machine_leftmost_orphan_bit(Machine* self, ArrayList* rows) {
    int button_count = ArrayList_size(self.buttons);
    int shift = JOLTAGE_BITS + button_count - 1;
    int bit = 1 << shift;

    # first, find a column w/out a leading one
    int i = 0;
    while i < rows.size() {
        if (bit & rows.get(i)) > 0 {
#            printf("  row %d has %d set\n", i, shift);
            i = i + 1;
        } else {
            printf("  row %d has %d unset\n", i, shift);
            shift = shift - 1;
            bit = bit >> 1;
            if (bit & rows.get(i)) == 0 {
                printf("    nor %d\n", shift);
                done;
            }
            again;
        }
    }
    if (bit & rows.get(rows.size() - 1)) > 0 {
        printf("  final row has %d set\n", shift);
        shift = shift - 1;
        bit = bit >> 1;
    }
    return bit;
}

fn Machine_min_answer_with_bit(Machine* self, ArrayList* rows, int bit) {
    # First, find the smallest answer that bit influences.
    int smallest = MAX_INTEGER;
    int i = 0;
    while i < rows.size() {
        if (bit & rows.get(i)) > 0 {
            smallest = min(smallest, rows.get(i) & JOLTAGE_MASK);
        }
        i = i + 1;
    }
    if smallest == MAX_INTEGER {
        printf("Failed to find a row in:\n");
        self.print_rows(rows);
        printf("with this bit set:\n");
        self.print_row(bit);
        exit(5);
    }

    return smallest;
}

# Rows are `BUTTONS_BITS` bits for the buttons' wirings, followed by
# `JOLTAGE_BITS` bits for the target joltage. And augmented matrix, where each
# row is encoded into a single integer.
fn Machine_build_rows(Machine* self) {
    ArrayList* buttons = self.buttons;
    int button_count = buttons.size();
    ArrayList* joltages = self.joltages;
    ArrayList* rows = ArrayList__new(joltages.size());
    int i = 0;
    while i < joltages.size() {
        int shift = self.light_count - i - 1;
        int btns = 0;
        int b = 0;
        while b < button_count {
            btns = btns << 1;
            btns = btns | (buttons.get(b) >> shift & 1);
            b = b + 1;
        }
        int row = btns << JOLTAGE_BITS;
        row = row + joltages.get(i);
        rows.push(row);
        i = i + 1;
    }
    return rows;
}

# This isn't quite Gaussian elimination, because Johann only has integers, not
# rationals (let alone reals). "Add a multiple of one row to another" is instead
# "subtract a row from another which has at least the same bits set." A much
# less powerful rule, but still sufficient.
fn Machine_eliminate(Machine* self, ArrayList* rows) {
    rows.sort(&intcmp_rev);
#    puts("");
#    self.print_rows(rows);
    int i = 0;
    while i < rows.size() {
        int a = rows.get(i);
        if a & OVERFLOW_MASK { exit(34); }
        int btn_bits = rows.get(i) & BUTTONS_MASK;
        int joltage = a & JOLTAGE_MASK;
        int j = 0;
        while j < i {
            int b = rows.get(j);
            if a == b {
                # exact dupe
                printf("  rows %d and %d are identical\n", j, i);
                rows.set(j, rows.pop());
                return self.eliminate(rows);
            }
            int bb = b & BUTTONS_MASK;
            int bj = b & JOLTAGE_MASK;
            if (btn_bits & bb) == btn_bits {
                if bj < joltage {
                    printf("it's impossible\n");
                    return false;
                }
                # a subset
                printf("  row %d is a subset of %d\n", i, j);
                rows.set(j, b - a);
                return self.eliminate(rows);
            }
            j = j + 1;
        }
        i = i + 1;
    }
    return true;
}

fn Machine_print_rows(Machine* self, ArrayList* rows) {
    int i = 0;
    while i < rows.size() {
        self.print_row(rows.get(i));
        i = i + 1;
    }
}

fn Machine_print_row(Machine* self, int row) {
    int button_count = ArrayList_size(self.buttons);
    int ans = row & JOLTAGE_MASK;
    int btn_bits = sizeof(int) * 8 - JOLTAGE_BITS;
    int len = sizeof(int) * 8 + 3; # divider
    char* str = malloc(len + 1); # null
    char* s = str + len;
    *s = null;
    int n = row;
    while s > str {
        s = s - 1;
        if s - str == btn_bits + 2 {
            # about to do the first button column, so divide
            *s = ' ';
            s = s - 1;
            *s = '|';
            s = s - 1;
            *s = ' ';
            s = s - 1;
        }
        if (n & 1) == 1 {
            *s = '1';
        } else {
            int i = s - str;
            if i >= btn_bits || i < (btn_bits - button_count) {
                *s = '.';
            } else {
                *s = '_';
            }
        }
        n = n >> 1;
    }
    printf("%s (%3d : %018x)\n", str, ans, row);
    free(str);
}

struct Counts {
    int light,
    int joltage,
}

#pub fn main() {
#    Machine* m = read_machine(1);
#    ArrayList* rows = ArrayList__new(16);
#    rows.push(0x183b000000000000);
#    rows.push(0x147900000000003b);
#    rows.push(0x14360000000000ea);
#    rows.push(0x100e000000000095);
#    rows.push(0x83f0000000000e8);
#    rows.push(0x480000000000011);
#    rows.push(0x47d0000000000ea);
#    rows.push(0x2a1000000000053);
#    rows.push(0x28d00000000008e);
#    rows.push(0x100000000000043);
#    rows.push(0xf1000000000030);
#    m.print_rows(rows);
#    puts("try w/");
#    m.print_row(m.missing_row(rows));
#    rows.drop();
#    m.drop();
#}

pub fn main() {
    Counts* cs = malloc(sizeof(Counts));
    cs.light = 0;
    cs.joltage = 0;
    int id = 0;
    while !iseof() {
        id = id + 1;
        printf("\nMachine #%d:\n", id);
        Machine* m = read_machine(id);
        int l = m.do_lights();
        int j = m.do_joltages();
        printf("  lights : %d\n  joltage: %d\n", l, j);
        cs.light = cs.light + l;
        cs.joltage = cs.joltage + j;
        m.drop();
    }
    printf("For Lights  : %d\n", cs.light);
    aocd_verify_a("%d", cs.light);
    printf("For Joltages: %d\n", cs.joltage);
#    aocd_verify_b("%d", cs.joltage);
    free(cs);
}

fn read_machine(int id) {
    if getchar() != '[' { exit(23); }
    int lights = 0;
    int len = 0;
    while peekchar() != ']' {
        lights = lights << 1;
        len = len + 1;
        if getchar() == '#' {
            lights = lights + 1;
        }
    }
    Machine* m = Machine__new(id, len, lights);
    if getchar() != ']' { exit(24); }
    if getchar() != ' ' { exit(25); }
    while peekchar() == '(' {
        getchar();
        int btn = 0;
        while true {
            int n = read_int();
            n = 1 << (len - n - 1);
            btn = btn | n;
            if getchar() != ',' { done; }
        }
        m.add_button(btn);
        if getchar() != ' ' { exit(26); }
    }
    if getchar() != '{' { exit(27); }
    while peekchar() != '}' {
        if peekchar() == ',' {
            getchar();
        }
        m.add_joltage(read_int());
    }
    if getchar() != '}' { exit(28); }
    if getchar() != 0xa { exit(29); }
    return m;
}

fn read_int() {
    int i = 0;
    while isdigit(peekchar()) {
        i = i * 10 + (getchar() - '0');
    }
    return i;
}
