# a follows z, and skip i, l, and o.
char* SUCCESSORS = "bcdefghjjkmmnppqrstuvwxyza"; # char[] lookup; SUCCESSORS['m' - 'a'] == 'n'

pub fn main() {
    char* pw = read_line(); # char[8]
    printf("Initial Password: '%s'\n", pw);
    findNext(pw);
    printf("Next Password   : '%s'\n", pw);
    aocd_verify_a("%s", pw);
    findNext(pw);
    printf("Third Password  : '%s'\n", pw);
    aocd_verify_b("%s", pw);
    free(pw);
}

fn findNext(char* pw) {
    increment(pw);
    while !isValidPassword(pw) {
        increment(pw);
    }
}

fn isValidPassword(char* pw) {
    # two passes is less efficient, but rather simpler
    if pairCount(pw) < 2 { return false; }
    if !hasRunOfThree(pw) { return false; }
    return true;
}

fn pairCount(char* pw) {
    int n = 0;
    char prev = pw[0];
    int i = 1;
    while i < 8 {
        char c = pw[i];
        if c == prev {
            # found a pair
            n = n + 1;
            c = null; # have to be non-overlapping; null will never match
        }
        i = i + 1;
        prev = c;
    }
    return n;
}

fn hasRunOfThree(char* pw) {
    int i = 1; # start at the second char
    char prev = pw[i];
    i = i + 1;
    char curr = pw[i];
    while i < 8 {
        if curr == prev + 1 {
            char c = pw[i - 2];
            if prev == c + 1 {
                return true;
            }
        }
        prev = curr;
        i = i + 1;
        curr = pw[i];
    }
    return false;
}

fn increment(char* pw) {
    char* succ = SUCCESSORS;
    int i = 7; # start at the end
    while i >= 0 {
        char c = pw[i];
        pw[i] = succ[c - 'a'];
        if c != 'z' {
            # didn't carry, so we're done
            return;
        }
        i = i - 1;
    }
}
