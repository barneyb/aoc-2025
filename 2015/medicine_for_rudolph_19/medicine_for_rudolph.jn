fn strcmp(char*, char*);
fn strhash(char*);
fn free(void*);
fn ArrayList_drop(void*);

struct ArrayList;
struct HashMap;
struct StringBuilder;

struct Repl {
    char* src,
    int slen,
    char* tgt,
    int tlen,
}

fn Repl__new(char* src, char* tgt) {
    Repl* r = malloc(sizeof(Repl));
    r.src = src;
    r.slen = strlen(src);
    r.tgt = tgt;
    r.tlen = strlen(tgt);
    return r;
}

fn Repl_drop(Repl* self) {
    free(self.src);
    free(self.tgt);
    free(self);
}

struct Machine {
    ArrayList* repls,
    int repl_count,
    int dead_ends
}

fn Machine_drop(Machine* self) {
    ArrayList_drop(self.repls);
    free(self);
}

pub fn main() {
    HashMap* replacements = HashMap__new_owned(&strhash, &strcmp, &free, &ArrayList_drop);
    ArrayList* repls = ArrayList__new_owned(10, &Repl_drop);
    char* line;
    while !iseof() {
        line = read_line();
        if strlen(line) == 0 {
            # end of the replacements
            free(line);
            done;
        }
        char* idx = strchr(line, ' ') - line;
        char* src = strprefix(line, idx);
        char* tgt = strsuffix(line, idx + 4);
        repls.push(Repl__new(strclone(src), strclone(tgt)));
        # printf("line '%s' is '%s' -> '%s'\n", line, src, tgt);
        ArrayList* targets = replacements.get(src);
        if targets != null {
            free(src);
        }
        if targets == null {
            targets = ArrayList__new_owned(4, &free);
            replacements.put(src, targets);
        }
        targets.push(tgt);
        free(line);
    }
    line = read_line();
#    printf("calib mol: %s\n", line);
    printf("Calibration Result: %d\n", calibrate(replacements, line));
    Machine* m = Machine__new(repls);
    printf("Fabrication Steps : %d\n", Machine_fabricate(m, line));
    printf("  (%d dead ends)\n", m.dead_ends);
    m.drop();
    free(line);
    replacements.drop();
}

# by length of target
fn replcmp(Repl* a, Repl* b) {
    return a.tlen - b.tlen;
}

fn Machine__new(ArrayList* repls) {
    repls.sort(&replcmp);
    Machine* m = malloc(sizeof(Machine));
    m.repls = repls;
    m.repl_count = repls.size();
    m.dead_ends = 0;
    return m;
}

fn Machine_dead_end(Machine* self) {
    self.dead_ends = self.dead_ends + 1;
    if self.dead_ends % 10_000 == 0 {
        printf("%d K dead ends\n", self.dead_ends / 1000);
    }
}

fn Machine_fabricate(Machine* self, char* goal) {
    # iterate backwards to shorten as quickly as possible
    int ri = self.repl_count - 1;
    while ri >= 0 {
        Repl* rep = ArrayList_get(self.repls, ri);
        ri = ri - 1;

        if strstr(goal, rep.tgt) == null { again; }

        int result = self.split_and_replace(goal, rep);
        if result > 0 {
            return result;
        }
    }
    self.dead_end();
    return 0;
}

fn wipe(char* str, int len) {
    while len > 0 {
        len = len - 1;
        str[len] = '.';
    }
}

fn Machine_split_and_replace(Machine* self, char* goal, Repl* rep) {
    ArrayList* parts = strsplit_after(goal, rep.tgt);
    char* s;
    int pi = parts.size() - 2; # last split doesn't have tgt
    while pi >= 0 {
        s = parts.get(pi);
        char* work = strclone(s);
        memcpy(work + strlen(work) - strlen(rep.tgt), rep.src, rep.slen + 1);
        parts.set(pi, work);
        work = strjoin(parts, "");
        free(parts.set(pi, s)); # frees the 'scratch' work

        if strcmp(work, "e") == 0 {
            free(work);
            parts.drop();
            return 1;
        }
        int result = self.fabricate(work);
        free(work);
        if result > 0 {
            parts.drop();
            return 1 + result;
        }

        pi = pi - 1;
    }
    parts.drop();
    return -1;
}

fn calibrate(HashMap* replacements, char* init) {
    HashMap* result = HashMap__new_owned(&strhash, &strcmp, &free, null);
    int start = 0;
    int i = 1;
    while true {
        char c = init[i];
        if c == null { done; }
        if c > 0x60 {
            # lowercase
            i = i + 1;
            again;
        }
        do_replacement(result, replacements, init, start, i);
        start = i;
        i = i + 1;
    }
    do_replacement(result, replacements, init, start, i);
    int size = result.size();
    result.drop();
    return size;
}

fn do_replacement(HashMap* result, HashMap* replacements, char* init, int start, int end) {
    char* mid = substr(init, start, end);
#    printf("replace '%s'\n", mid);
    ArrayList* repls = replacements.get(mid);
    if repls == null {
#        puts("  no replacements found");
        free(mid);
        return;
    }
    restitch(strprefix(init, start),
             strsuffix(init, end),
             result,
             repls);
    free(mid);
}

fn restitch(char* prefix, char* suffix, HashMap* result, ArrayList* repls) {
#    printf("  restitch '%s' .. '%s'\n", prefix, suffix);
    int i = 0;
    int l = repls.size();
    while i < l {
        StringBuilder* sb = StringBuilder__new();
        sb.push_str(prefix);
        sb.push_str(repls.get(i));
        sb.push_str(suffix);
        char* mol = sb.into_chars();
        i = i + 1;

        if result.get(mol) != null {
#            printf("Already seen '%s'\n", mol);
            free(mol);
            again;
        }

        # it's new!
#        printf("A new one: '%s'\n", mol);
        result.put(mol, 1);
    }
    free(prefix);
    free(suffix);
}

fn strprefix(char* str, int len) {
    return substr(str, 0, len);
}

fn strsuffix(char* str, int from) {
    return strclone(str + from);
}
