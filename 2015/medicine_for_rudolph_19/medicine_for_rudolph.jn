fn strcmp(char* lhs, char* rhs);
fn free(void* ptr);
fn ArrayList_drop(void* self);

struct ArrayList;
struct TreeMap;
struct StringBuilder;

struct Repl {
    char* src,
    char* tgt,
}

fn Repl__new(char* src, char* tgt) {
    Repl* r = malloc(sizeof(Repl));
    r.src = src;
    r.tgt = tgt;
    return r;
}

fn Repl_drop(Repl* self) {
    free(self.src);
    free(self.tgt);
    free(self);
}

pub fn main() {
    TreeMap* replacements = TreeMap__new_owned(&strcmp, &free, &ArrayList_drop);
    ArrayList* repls = ArrayList__new_owned(10, &Repl_drop);
    char* line;
    while !iseof() {
        line = read_line();
        if strlen(line) == 0 {
            # end of the replacements
            free(line);
            done;
        }
        char* idx = strchr(line, ' ') - line;
        char* src = strprefix(line, idx);
        char* tgt = strsuffix(line, idx + 4);
        repls.push(Repl__new(strclone(src), strclone(tgt)));
        # printf("line '%s' is '%s' -> '%s'\n", line, src, tgt);
        ArrayList* targets = replacements.get(src);
        if targets != null {
            free(src);
        }
        if targets == null {
            targets = ArrayList__new_owned(4, &free);
            replacements.put(src, targets);
        }
        targets.push(tgt);
        free(line);
    }
    line = read_line();
#    printf("calib mol: %s\n", line);
    printf("Calibration Result: %d\n", calibrate(replacements, line));
    printf("Fabrication Steps : %d\n", fabricate(repls, line));
    free(line);
    repls.drop();
    replacements.drop();
}

fn fabricate(ArrayList* repls, char* goal) {
#    # iterating backwards fails the real input for unknown reasons?
#    int ri = repls.size() - 1;
#    while ri >= 0 {
#        Repl* rep = repls.get(ri);
#        ri = ri - 1;
    int ri = 0;
    while ri < repls.size() {
        Repl* rep = repls.get(ri);
        ri = ri + 1;

        if strstr(goal, rep.tgt) == null { again; }

#        printf("for %s => %s\n", rep.src, rep.tgt);
        ArrayList* parts = strsplitafter(goal, rep.tgt);
        char* s;
#        s = parts.to_string(null);
#        printf("  split '%s'\n    after '%s':\n    %s\n", goal, rep.tgt, s);
#        free(s);
        int pi = parts.size() - 2; # last split doesn't have tgt
        while pi >= 0 {
            s = parts.get(pi);
            char* work = strclone(s);
#            printf("    from '%s' (at %d )", work, strlen(work) - strlen(rep.tgt));
            memcpy(work + strlen(work) - strlen(rep.tgt), rep.src, strlen(rep.src) + 1);
#            printf(" to '%s'\n", work);
            parts.set(pi, work);
            work = strjoin(parts, "");
#            printf("    now '%s'\n", work);
            if strcmp(work, "e") == 0 {
                return 1;
            }
            return 1 + fabricate(repls, work);

            free(parts.set(pi, s));
            pi = pi - 1;
        }
        parts.drop();
    }
    printf("Dead end: '%s'\n", goal);
    return 0;
}

#    printf("goal: '%s'\n", goal);
#    printf("split H: %s\n", ArrayList_to_string(strsplit(goal, "H"), null));
#    printf("split O: %s\n", ArrayList_to_string(strsplit(goal, "O"), null));
#    printf("split OH: %s\n", ArrayList_to_string(strsplit(goal, "OH"), null));
#    printf("split HO: %s\n", ArrayList_to_string(strsplit(goal, "HO"), null));
#    printf("split -: %s\n", ArrayList_to_string(strsplit(goal, "-"), null));

fn ArrayList_to_string(ArrayList* self, void* el_to_string) { # todo: jstdlib?
    int l = self.size();
    if l == 0 {
        return strclone("[]");
    }
    StringBuilder* sb = StringBuilder__new(l);
    sb.push('[');
    int i = 0;
    while i < l {
        if i > 0 {
            sb.push(',');
        }
        void* el = self.get(i);
        if el_to_string != null {
            el = el_to_string(el, null);
        }
        sb.push_str(el);
        if el_to_string != null {
            free(el);
        }
        i = i + 1;
    }
    sb.push(']');
    return sb.into_chars();
}

fn strjoin(ArrayList* parts, char* delim) {
    int l = parts.size();
    if l == 0 { return ""; }
    StringBuilder* sb = StringBuilder__new(l);
    sb.push_str(parts.get(0));
    int i = 1;
    while i < l {
        sb.push_str(delim);
        sb.push_str(parts.get(i));
        i = i + 1;
    }
    return sb.into_chars();
}

# todo: auto-drop, instead of returning old? Hmm.
fn ArrayList_set(ArrayList* self, int i, void el) { # todo: jstdlib
    if i < 0 { panic(-i, "Index out of bounds\n", 20); }
    if i >= self.size() { panic(i, "Index out of bounds\n", 20); }
    self = self + 0x10; # todo: struct!
    void* arr = *self;
    arr = arr + i * 0x8;
    void old = *arr;
    *arr = el;
    return old;
}

fn calibrate(TreeMap* replacements, char* init) {
    TreeMap* result = TreeMap__new_owned(&strcmp, &free, null);
    int start = 0;
    int i = 1;
    while true {
        char c = init[i];
        if c == null { done; }
        if c > 0x60 {
            # lowercase
            i = i + 1;
            again;
        }
        do_replacement(result, replacements, init, start, i);
        start = i;
        i = i + 1;
    }
    do_replacement(result, replacements, init, start, i);
    int size = result.size();
    result.drop();
    return size;
}

fn do_replacement(TreeMap* result, TreeMap* replacements, char* init, int start, int end) {
    char* mid = substr(init, start, end);
#    printf("replace '%s'\n", mid);
    ArrayList* repls = replacements.get(mid);
    if repls == null {
#        puts("  no replacements found");
        free(mid);
        return;
    }
    restitch(strprefix(init, start),
             strsuffix(init, end),
             result,
             repls);
    free(mid);
}

fn restitch(char* prefix, char* suffix, TreeMap* result, ArrayList* repls) {
#    printf("  restitch '%s' .. '%s'\n", prefix, suffix);
    int i = 0;
    int l = repls.size();
    while i < l {
        StringBuilder* sb = StringBuilder__new();
        sb.push_str(prefix);
        sb.push_str(repls.get(i));
        sb.push_str(suffix);
        char* mol = sb.into_chars();
        i = i + 1;

        if result.get(mol) != null {
#            printf("Already seen '%s'\n", mol);
            free(mol);
            again;
        }

        # it's new!
#        printf("A new one: '%s'\n", mol);
        result.put(mol, 1);
    }
    free(prefix);
    free(suffix);
}

fn strprefix(char* str, int len) {
    return substr(str, 0, len);
}

fn strsuffix(char* str, int from) {
    return strclone(str + from);
}

# I return an `ArrayList` containing substrings of `str`, delimited by `delim`.
# If `delim` is the empty string, panic.
fn strsplit(char* str, char* delim) { # todo: to jstdlib
    int len = strlen(delim);
    if len == 0 { panic(4, "empty delim to strsplit", 23); }
    ArrayList* parts = ArrayList__new_owned(10, &free);
    char* ptr = strstr(str, delim);
    while ptr != null {
        parts.push(substr(str, 0, ptr - str));
        str = ptr + len;
        ptr = strstr(str, delim);
    }
    parts.push(substr(str, 0, strlen(str)));
    return parts;
}

# I return an `ArrayList` containing substrings of `str`, delimited by `delim`.
# If `delim` is the empty string, panic.
fn strsplitafter(char* str, char* delim) { # todo: to jstdlib
    int len = strlen(delim);
    if len == 0 { panic(4, "empty delim to strsplit", 23); }
    ArrayList* parts = ArrayList__new_owned(10, &free);
    char* ptr = strstr(str, delim);
    while ptr != null {
        parts.push(substr(str, 0, ptr - str + len));
        str = ptr + len;
        ptr = strstr(str, delim);
    }
    parts.push(substr(str, 0, strlen(str)));
    return parts;
}

# I return a pointer to the first instance of `substr` within `str`, or null if
# there are no instances. If `substr` is the empty string, `str` is returned.
fn strstr(char* str, char* substr) { # todo: to jstdlib
    # if substr is empty, it matches the start of str
    char first_char = *substr;
    if first_char == null { return str; }

    # otherwise, search
    char curr = *str;
    while curr != null {
        if curr == first_char {
            # the first chars matched, check the rest
            char* lhs = str;
            char* rhs = substr;
            char l = *lhs;
            char r = *rhs;
            while true {
                if r == null {
                    # found it!
                    return str;
                }
                if l != r {
                    done;
                }
                lhs = lhs + 1;
                rhs = rhs + 1;
                l = *lhs;
                r = *rhs;
            }
        }
        str = str + 1;
        curr = *str;
    }

    # didn't find it
    return null;
}
