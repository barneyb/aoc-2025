
struct StringBuilder;

pub fn ArrayList_to_string(ArrayList* self, void* el_to_string) {
    int l = self.size();
    if l == 0 {
        return strclone("[]");
    }
    StringBuilder* sb = StringBuilder__new(l);
    sb.push('[');
    int i = 0;
    while i < l {
        if i > 0 {
            sb.push(',');
        }
        void* el = self.get(i);
        if el_to_string != null {
            el = el_to_string(el, null);
        }
        sb.push_str(el);
        if el_to_string != null {
            free(el);
        }
        i = i + 1;
    }
    sb.push(']');
    return sb.into_chars();
}

pub fn ArrayList_sort(ArrayList* self, void* cmp) {
    int hi = self.size();
    self = self + 0x10; # todo: struct!
    void* arr = *self;
    qsort(arr, 0, hi - 1, cmp);
}

fn qsort(void* arr, int lo, int hi, void* cmp) {
    # todo: quadratic protection if sorted
    if lo < hi {
        int p = qsort_part(arr, lo, hi, cmp);
        qsort(arr, lo,    p,  cmp);
        qsort(arr, p + 1, hi, cmp);
    }
}

fn qsort_part(void* arr, int lo, int hi, void* cmp) {
    void pivot = arr[lo];
    # start just outside the target range
    int l = lo - 1;
    int r = hi + 1;
    while true {
        # move left index to the right at least once
        while true {
            l = l + 1;
            if cmp(arr[l], pivot) >= 0 { done; }
        }
        # and same for right index
        while true {
            r = r - 1;
            if cmp(arr[r], pivot) <= 0 { done; }
        }
        # if they crossed, partitioning is complete
        if l >= r { return r; }

        # swap the two elements and keep going
        void* t = arr[l];
        arr[l] = arr[r];
        arr[r] = t;
    }
}

# returning old is better, as the caller know whether it needs to be freed or not
pub fn ArrayList_set(ArrayList* self, int i, void el) {
    if i < 0 { panic(-i, "Index out of bounds\n", 20); }
    if i >= self.size() { panic(i, "Index out of bounds\n", 20); }
    self = self + 0x10; # todo: struct!
    void* arr = *self;
    arr = arr + i * 0x8;
    void old = *arr;
    *arr = el;
    return old;
}
