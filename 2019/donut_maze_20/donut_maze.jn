pub struct HashMap;
struct Portal; # todo: shouldn't be needed
struct Queue; # todo: shouldn't be needed
pub struct ArrayList;

pub struct Map {
    int width,
    int start,
    int goal,
    # Map<int, ArrayList<int>>
    HashMap* adjacent,
    ArrayList* portals,
}

pub fn Map__new(int width, int start, int goal, HashMap* adj, ArrayList* portals) {
    Map* m = malloc(sizeof(Map));
    m.width = width;
    m.start = start;
    m.goal = goal;
    m.adjacent = adj;
    m.portals = portals;
    return m;
}

fn Map_drop(Map* self) {
    HashMap_drop(self.adjacent);
    ArrayList_drop(self.portals);
    free(self);
}

# hash helpers todo: don't make callers supply these (for primitives). Three times?!
fn id(void a) { return a; }
fn cmp(void a, void b) { return a - b; }

pub fn main(int argc, char** argv) {
    Map* m = parse();

    add_portals_as_edges(m);
    # collapsing linear series of nodes is tricky, as both nodes and edges
    # are represented uniformly, but can't be collapsed uniformly.
    remove_dead_ends(m);

    if argc > 1 { if strcmp(argv[1], "--graph") == 0 {
        graphviz(m);
        m.drop();
        return;
    } }
    printf("Start: %d (%d:%d)\n", m.start, m.start / m.width + 1, m.start % m.width + 1);
    printf("Goal : %d (%d:%d)\n", m.goal, m.goal / m.width + 1, m.goal % m.width + 1);
    printf("Adj #: %d\n", HashMap_size(m.adjacent));
    printf("Port#: %d\n", ArrayList_size(m.portals));

    printf("Shortest Path: %d steps\n", path_length(m));

    m.drop();
}

struct State {
    int pos,
    int steps,
}

fn State__new(int pos, int steps) {
    State* s = malloc(sizeof(State));
    s.pos = pos;
    s.steps = steps;
    return s;
}

fn path_length(Map* m) {
    Queue* q = Queue__new_owned(&free);
    q.push(State__new(m.start, 0));
    HashMap* visited = HashMap__new(&id, &cmp);
    int len = -1;

    while q.size() > 0 {
        State* s = q.remove();
        if visited.put(s.pos, 1) != null {
            free(s);
            again;
        }
        if s.pos == m.goal {
            len = s.steps;
            free(s);
            done;
        }
        ArrayList* adj = HashMap_get(m.adjacent, s.pos);
        int i = adj.size();
        while i > 0 {
            i = i - 1;
            q.push(State__new(adj.get(i), s.steps + 1));
        }
        free(s);
    }

    visited.drop();
    q.drop();
    return len;
}

fn remove_dead_ends(Map* m) {
    Queue* q = Queue__new_owned(&free);
    q.push(m.start);
    HashMap* visited = HashMap__new(&id, &cmp);

    while q.size() > 0 {
        int u = q.remove();
        if visited.put(u, u) != null {
            again;
        }
        ArrayList* adj = HashMap_get(m.adjacent, u);
        if adj.size() == 1 { if u != m.start { if u != m.goal { # todo: comical lack of boolean ops!
            dead_end(m, u, adj.get(0));
            again;
        } } }
        int i = adj.size();
        while i > 0 {
            i = i - 1;
            q.push(adj.get(i));
        }
    }

    visited.drop();
    q.drop();
}

fn dead_end(Map* m, int u, int v) {
#    printf(" %d [style=filled fillcolor=yellow]\n", u);
    ArrayList* adj = HashMap_get(m.adjacent, v);
    # todo: complicated/expensive m.adjacent.get(v).remove(u)
    ArrayList* wo = ArrayList__new(adj.size());
    int i = 0;
    while i < adj.size() {
        int n = adj.get(i);
        if n != u {
            wo.push(n);
        }
        i = i + 1;
    }
    adj.drop();
    HashMap_put(m.adjacent, v, wo);
    if wo.size() == 1 {
        dead_end(m, v, wo.get(0));
        return;
    }
}

fn add_portals_as_edges(Map* m) {
    HashMap* adjacent = m.adjacent;
    ArrayList* portals = m.portals;
    int i = 0;
    while i < portals.size() {
        Portal* p = portals.get(i);
        ArrayList_push(adjacent.get(p.u()), p.v());
        ArrayList_push(adjacent.get(p.v()), p.u());
        i = i + 1;
    }
}

fn graphviz(Map* m) {
    puts("");
    puts("strict graph {");
    printf("  graph [rank=source] { %d [shape=polygon style=filled fillcolor=%s] }\n", m.start, "lime");
    printf("  graph [rank=sink] { %d [shape=polygon style=filled fillcolor=%s] }\n", m.goal, "pink");
    puts("");
    Queue* q = Queue__new();
    q.push(m.start);

    ArrayList* portals = m.portals;
    int i = 0;
    while i < portals.size() {
        Portal* p = portals.get(i);
        q.push(p.u());
        q.push(p.v());
        printf(" %d -- %d [label=%s penwidth=2 weight=0 color=red dir=forward]\n", p.u(), p.v(), p.label());
        i = i + 1;
    }

    HashMap* visited = HashMap__new(&id, &cmp);
    HashMap* adjacent = m.adjacent;
    while q.size() > 0 {
        int u = q.remove();
        if visited.put(u, u) != null { again; }
        ArrayList* adj = adjacent.get(u);
        i = 0;
        while i < adj.size() {
            int v = adj.get(i);
            q.push(v);
            printf("  %d [label=r%dc%d]\n", v, v / m.width + 1, v % m.width + 1);
            # only draw edges once
            if !visited.contains(v) {
                printf("  %d -- %d\n", u, v);
            }
            i = i + 1;
        }
    }

    puts("}");
    puts("");
    visited.drop();
    q.drop();
}
