struct Edge;
struct Graph;
pub struct HashMap;
struct Portal;
struct Queue;
pub struct ArrayList;

pub struct Map {
    int width,
    int start,
    int goal,
    ArrayList* open_tiles,
    # Map<int, ArrayList<int>> - only NORTH and WEST!
    HashMap* adjacent,
    ArrayList* portals,
}

pub fn Map__new(int width, int start, int goal, ArrayList* open_tiles, HashMap* adj, ArrayList* portals) {
    Map* m = malloc(sizeof(Map));
    m.width = width;
    m.start = start;
    m.goal = goal;
    m.open_tiles = open_tiles;
    m.adjacent = adj;
    m.portals = portals;
    return m;
}

fn Map_drop(Map* self) {
    ArrayList_drop(self.open_tiles);
    HashMap_drop(self.adjacent);
    ArrayList_drop(self.portals);
    free(self);
}

struct Weight {
    int len,
    char* label, # not owned!
    int portal_dir,
}

fn Weight__new(int len, char* label, int portal_dir) {
    Weight* w = malloc(sizeof(Weight));
    w.len = len;
    w.label = label;
    w.portal_dir = portal_dir;
    return w;
}

fn build_graph(Map* m) {
    Graph* g = Graph__new_owned_weights();
    ArrayList* list = m.portals;
    int i = list.size();
    while i > 0 {
        i = i - 1;
        Portal* p = list.get(i);
        # portals are bi-directional
        g.add_edge(p.u(), p.v(), Weight__new(1, p.label(), 1));
        g.add_edge(p.v(), p.u(), Weight__new(1, p.label(), -1));
    }

    list = m.open_tiles;
    i = list.size();
    while i > 0 {
        i = i - 1;
        int u = list.get(i);
        ArrayList* adj = HashMap_get(m.adjacent, u);
        if adj == null { again; }
        int j = adj.size();
        while j > 0 {
            j = j - 1;
            int v = adj.get(j);
            # parse only records NORTH and WEST adjacencies
            g.add_edge(u, v, Weight__new(1, null, 0));
            g.add_edge(v, u, Weight__new(1, null, 0));
        }
    }

    return g;
}

void MAP = null; # it's a "closure"!
fn label_node(int u) {
    Map* m = MAP;
    printf("r%dc%d", u / m.width + 1, u % m.width + 1);
    if u == m.start {
        printf(" shape=polygon style=filled fillcolor=lime", m.start);
    } else if u == m.goal {
        printf(" shape=polygon style=filled fillcolor=pink", m.goal);
    }
}

fn label_edge(Edge* e) {
    Weight* w = e.weight();
    if w.portal_dir == 0 {
        printf("%d", w.len);
    } else {
        printf("%c%s : %d : %d%c penwidth=2 color=red", '"', w.label, w.len, w.portal_dir, '"');
    }
}

pub fn main(int argc, char** argv) {
    HashMap* opts = get_opts(argc, argv);
    Map* m = parse();
    printf("# Start: %d (%d:%d)\n", m.start, m.start / m.width + 1, m.start % m.width + 1);
    printf("# Goal : %d (%d:%d)\n", m.goal, m.goal / m.width + 1, m.goal % m.width + 1);
    printf("# Adj #: %d\n", HashMap_size(m.adjacent));
    printf("# Port#: %d\n", ArrayList_size(m.portals));

    Graph* g = build_graph(m);
    if opts.contains("--dot") {
        MAP = m; # "close over" m
#        g.dot_nodes(&label_node,
#                    &label_edge,
#                    m.open_tiles);
#        g.dot_reachable(&label_node,
#                        &label_edge,
#                        m.start);
        g.dot(&label_node, &label_edge);
    } else {
        int part_one = path_length_portals(m, g);
        printf("Shortest Path (Portals): %d steps\n", part_one);
        aocd_verify_a("%d", part_one);

        if opts.contains("no-part-two") {
            puts("Skipping part two.");
        } else {
            int part_two = path_length_nesting(m, g);
            printf("Shortest Path (Nesting): %d steps\n", part_two);
            aocd_verify_b("%d", part_two);
        }
    }

    g.drop();
    m.drop();
    opts.drop();
}

struct State {
    int pos,
    int steps,
    int level,
}

fn State__new(int pos, int steps, int level) {
    State* s = malloc(sizeof(State));
    s.pos = pos;
    s.steps = steps;
    s.level = level;
    return s;
}

fn cross_edge_portals(State* s, Edge* e) {
    Weight* w = e.weight();
    return State__new(e.v(), s.steps + w.len, 0);
}

fn path_length_portals(Map* m, Graph* g) {
    return path_length_internal(m, g, &cross_edge_portals);
}

fn cross_edge_nesting(State* s, Edge* e) {
    Weight* w = e.weight();
    if w.portal_dir == 0 {
        return State__new(e.v(), s.steps + w.len, s.level);
    }
    int level = s.level + w.portal_dir;
    if level < 0 {
        return null;
    }
    return State__new(e.v(), s.steps + w.len, level);
}

fn path_length_nesting(Map* m, Graph* g) {
    return path_length_internal(m, g, &cross_edge_nesting);
}

fn path_length_internal(Map* m, Graph* g, void* cross_edge) {
    Queue* q = Queue__new_owned(&free);
    q.push(State__new(m.start, 0, 0));
    HashMap* visited = HashMap__new(null, null);
    int len = -1;

    while q.size() > 0 {
        State* s = q.remove();
        if visited.put(s.pos + s.level * 0xffffffff, 1) != null {
            free(s);
            again;
        }
        if s.pos == m.goal { if s.level == 0 {
            len = s.steps;
            free(s);
            done;
        } }
        ArrayList* edges = g.out_edges(s.pos);
        int i = edges.size();
        while i > 0 {
            i = i - 1;
            Edge* e = edges.get(i);
            State* next = cross_edge(s, e);
            if next != null {
                q.push(next);
            }
        }
        free(s);
    }

    visited.drop();
    q.drop();
    return len;
}
