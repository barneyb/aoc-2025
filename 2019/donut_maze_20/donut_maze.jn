pub struct HashMap;
struct Portal; # todo: shouldn't be needed
struct Queue; # todo: shouldn't be needed
pub struct ArrayList;

pub struct Map {
    int width,
    int start,
    int goal,
    # Map<int, ArrayList<int>>
    HashMap* adjacent,
    ArrayList* portals,
}

pub fn Map__new(int width, int start, int goal, HashMap* adj, ArrayList* portals) {
    Map* m = malloc(sizeof(Map));
    m.width = width;
    m.start = start;
    m.goal = goal;
    m.adjacent = adj;
    m.portals = portals;
    return m;
}

fn Map_drop(Map* self) {
    HashMap_drop(self.adjacent);
    ArrayList_drop(self.portals);
    free(self);
}

# hash helpers todo: don't make callers supply these (for primitives). Three times?!
fn id(void a) { return a; }
fn cmp(void a, void b) { return a - b; }

struct Edge {
    int u,
    int v,
    void* weight, # REQUIRED to be a pointer to an owned
                  # allocation with no owned subdata
}

fn Edge__new(int u, int v, void* weight) {
    Edge* e = malloc(sizeof(Edge));
    e.u = u;
    e.v = v;
    e.weight = weight;
    return e;
}

fn Edge_drop(Edge* self) {
    free(self.weight);
    free(self);
}

struct Graph { # todo: this shouldn't have to precede first use
    # Map<int, ArrayList<void>>
    HashMap* edges,
}

fn Graph__new() {
    Graph* g = malloc(sizeof(Graph));
    g.edges = HashMap__new_owned(&id, &cmp, null, &ArrayList_drop);
    return g;
}

fn Graph_drop(Graph* self) {
    HashMap_drop(self.edges);
    free(self);
}

fn Graph_add_edge(Graph* self, int u, int v, Weight* weight) {
    ArrayList* adj = self.out_edges(u);
    if adj == null {
        adj = ArrayList__new_owned(2, &Edge_drop);
        HashMap_put(self.edges, u, adj);
    }
    adj.push(Edge__new(u, v, weight));
}

fn Graph_out_degree(Graph* self, int u) {
    ArrayList* adj = self.out_edges(u);
    return adj.size();
}

fn Graph_out_edges(Graph* self, int u) {
    return HashMap_get(self.edges, u);
}

struct Weight {
    int len,
    char* label, # not owned!
    int portal_dir,
}

fn Weight__new(int len, char* label, int portal_dir) {
    Weight* w = malloc(sizeof(Weight));
    w.len = len;
    w.label = label;
    w.portal_dir = portal_dir;
    return w;
}

fn build_graph(Map* m) {
    Graph* g = Graph__new();
    Queue* q = Queue__new();
    q.push(m.start);
    ArrayList* portals = m.portals;
    int i = portals.size();
    while i > 0 {
        i = i - 1;
        Portal* p = portals.get(i);
        q.push(p.u());
        q.push(p.v());
        g.add_edge(p.u(), p.v(), Weight__new(1, p.label(), 1));
        g.add_edge(p.v(), p.u(), Weight__new(1, p.label(), -1));
    }
    HashMap* visited = HashMap__new(&id, &cmp);

    while q.size() > 0 {
        int u = q.remove();
        if visited.put(u, u) != null {
            again;
        }
        ArrayList* adj = HashMap_get(m.adjacent, u);
        i = adj.size();
        while i > 0 {
            i = i - 1;
            int v = adj.get(i);
            q.push(v);
            g.add_edge(u, v, Weight__new(1, null, 0));
            g.add_edge(v, u, Weight__new(1, null, 0));
        }
    }

    visited.drop();
    q.drop();
    return g;
}

pub fn main(int argc, char** argv) {
    Map* m = parse();

    Graph* g = build_graph(m);

    if argc > 1 { if strcmp(argv[1], "--graph") == 0 {
        graphviz(m, g);
        g.drop();
        m.drop();
        return;
    } }
    printf("Start: %d (%d:%d)\n", m.start, m.start / m.width + 1, m.start % m.width + 1);
    printf("Goal : %d (%d:%d)\n", m.goal, m.goal / m.width + 1, m.goal % m.width + 1);
    printf("Adj #: %d\n", HashMap_size(m.adjacent));
    printf("Port#: %d\n", ArrayList_size(m.portals));

    printf("Shortest Path: %d steps\n", path_length(m, g));

    g.drop();
    m.drop();
}

struct State {
    int pos,
    int steps,
}

fn State__new(int pos, int steps) {
    State* s = malloc(sizeof(State));
    s.pos = pos;
    s.steps = steps;
    return s;
}

fn path_length(Map* m, Graph* g) {
    Queue* q = Queue__new_owned(&free);
    q.push(State__new(m.start, 0));
    HashMap* visited = HashMap__new(&id, &cmp);
    int len = -1;

    while q.size() > 0 {
        State* s = q.remove();
        if visited.put(s.pos, 1) != null {
            free(s);
            again;
        }
        if s.pos == m.goal {
            len = s.steps;
            free(s);
            done;
        }
        ArrayList* edges = g.out_edges(s.pos);
        int i = edges.size();
        while i > 0 {
            i = i - 1;
            Edge* e = edges.get(i);
            Weight* w = e.weight;
            q.push(State__new(e.v, s.steps + w.len));
        }
        free(s);
    }

    visited.drop();
    q.drop();
    return len;
}

fn graphviz(Map* m, Graph* g) {
    puts("strict graph {");
    printf("  graph [rank=source] { %d [shape=polygon style=filled fillcolor=%s] }\n", m.start, "lime");
    printf("  graph [rank=sink] { %d [shape=polygon style=filled fillcolor=%s] }\n", m.goal, "pink");
    puts("");
    Queue* q = Queue__new();
    q.push(m.start);
    # also start at every portal
    ArrayList* portals = m.portals;
    int i = 0;
    while i < portals.size() {
        Portal* p = portals.get(i);
        q.push(p.u());
        q.push(p.v());
        i = i + 1;
    }

    HashMap* visited = HashMap__new(&id, &cmp);
    while q.size() > 0 {
        int u = q.remove();
        if visited.put(u, u) != null { again; }
        ArrayList* edges = g.out_edges(u);
        i = edges.size();
        while i > 0 {
            i = i - 1;
            Edge* e = edges.get(i);
            q.push(e.v);
            printf("  %d [label=r%dc%d]\n", e.v, e.v / m.width + 1, e.v % m.width + 1);
            # only draw edges once
            if !visited.contains(e.v) {
                printf("  %d -- %d", u, e.v);
                Weight* w = e.weight;
                if w.portal_dir == 0 {
                    printf(" [label=%d]\n", w.len);
                    again;
                }
                # it's be easier to draw portals from the map directly, but
                # do it from the graph, as that's where the data will be
                # read from during the walk.
                char* dir = "forward";
                if w.portal_dir < 0 { dir = "back"; }
                printf(" [label=%s_%d penwidth=2 weight=0 color=red dir=%s]\n", w.label, w.len, dir);
            }
        }
    }

    puts("}");
    visited.drop();
    q.drop();
}
