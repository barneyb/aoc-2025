pub struct HashMap;
struct Portal;
struct Queue;
pub struct ArrayList;

pub struct Map {
    int width,
    int start,
    int goal,
    ArrayList* open_tiles,
    # Map<int, ArrayList<int>> - only NORTH and WEST!
    HashMap* adjacent,
    ArrayList* portals,
}

pub fn Map__new(int width, int start, int goal, ArrayList* open_tiles, HashMap* adj, ArrayList* portals) {
    Map* m = malloc(sizeof(Map));
    m.width = width;
    m.start = start;
    m.goal = goal;
    m.open_tiles = open_tiles;
    m.adjacent = adj;
    m.portals = portals;
    return m;
}

fn Map_drop(Map* self) {
    ArrayList_drop(self.open_tiles);
    HashMap_drop(self.adjacent);
    ArrayList_drop(self.portals);
    free(self);
}

struct Edge {
    int u,
    int v,
    void* weight, # REQUIRED to be a pointer to an owned
                  # allocation with no owned subdata
}

fn Edge__new(int u, int v, void* weight) {
    Edge* e = malloc(sizeof(Edge));
    e.u = u;
    e.v = v;
    e.weight = weight;
    return e;
}

fn Edge_drop(Edge* self) {
    free(self.weight);
    free(self);
}

struct Graph {
    # Map<int, ArrayList<void>>
    HashMap* edges,
}

fn Graph__new() {
    Graph* g = malloc(sizeof(Graph));
    g.edges = HashMap__new_owned(null, null, null, &ArrayList_drop);
    return g;
}

fn Graph_drop(Graph* self) {
    HashMap_drop(self.edges);
    free(self);
}

fn Graph_add_edge(Graph* self, int u, int v, Weight* weight) {
    ArrayList* adj = self.out_edges(u);
    if adj == null {
        adj = ArrayList__new_owned(2, &Edge_drop);
        HashMap_put(self.edges, u, adj);
    }
    adj.push(Edge__new(u, v, weight));
}

fn Graph_out_degree(Graph* self, int u) {
    ArrayList* adj = self.out_edges(u);
    return adj.size();
}

fn Graph_out_edges(Graph* self, int u) {
    return HashMap_get(self.edges, u);
}

struct Weight {
    int len,
    char* label, # not owned!
    int portal_dir,
}

fn Weight__new(int len, char* label, int portal_dir) {
    Weight* w = malloc(sizeof(Weight));
    w.len = len;
    w.label = label;
    w.portal_dir = portal_dir;
    return w;
}

fn build_graph(Map* m) {
    Graph* g = Graph__new();
    ArrayList* list = m.portals;
    int i = list.size();
    while i > 0 {
        i = i - 1;
        Portal* p = list.get(i);
        # portals are bi-directional
        g.add_edge(p.u(), p.v(), Weight__new(1, p.label(), 1));
        g.add_edge(p.v(), p.u(), Weight__new(1, p.label(), -1));
    }

    list = m.open_tiles;
    i = list.size();
    while i > 0 {
        i = i - 1;
        int u = list.get(i);
        ArrayList* adj = HashMap_get(m.adjacent, u);
        if adj == null { again; }
        int j = adj.size();
        while j > 0 {
            j = j - 1;
            int v = adj.get(j);
            # parse only records NORTH and WEST adjacencies
            g.add_edge(u, v, Weight__new(1, null, 0));
            g.add_edge(v, u, Weight__new(1, null, 0));
        }
    }

    return g;
}

fn get_opts(int argc, char** argv) { # todo: jstdlib?
    HashMap* opts = HashMap__new_owned(&strhash, &strcmp, &free, &free);
    int i = 1;
    char* last_opt;
    char* temp = "?";
    while i < argc {
        char* a = argv[i];
        i = i + 1;
        if a[0] == '-' {
            if a[1] == '-' {
                # long opt
                last_opt = strclone(a + 2);
                opts.put(last_opt, null);
            } else {
                # short opt(s)
                a = a + 1;
                while *a != null {
                    *temp = *a;
                    last_opt = strclone(temp);
                    opts.put(last_opt, null);
                    a = a + 1;
                }
            }
        } else {
            if last_opt != null {
                # option value
                opts.put(last_opt, a);
                last_opt = null;
            } else {
                # rando
                opts.put(a, null);
            }
        }
    }
    return opts;
}

pub fn main(int argc, char** argv) {
    HashMap* opts = get_opts(argc, argv);
    Map* m = parse();
    printf("# Start: %d (%d:%d)\n", m.start, m.start / m.width + 1, m.start % m.width + 1);
    printf("# Goal : %d (%d:%d)\n", m.goal, m.goal / m.width + 1, m.goal % m.width + 1);
    printf("# Adj #: %d\n", HashMap_size(m.adjacent));
    printf("# Port#: %d\n", ArrayList_size(m.portals));

    Graph* g = build_graph(m);
    if opts.contains("graph") {
        graphviz(m, g);
    } else {
        printf("Shortest Path (Portals): %d steps\n", path_length_portals(m, g));

        if opts.contains("no-part-two") {
            puts("Skipping part two.");
        } else {
            printf("Shortest Path (Nesting): %d steps\n", path_length_nesting(m, g));
        }
    }

    g.drop();
    m.drop();
    opts.drop();
}

struct State {
    int pos,
    int steps,
    int level,
}

fn State__new(int pos, int steps, int level) {
    State* s = malloc(sizeof(State));
    s.pos = pos;
    s.steps = steps;
    s.level = level;
    return s;
}

fn cross_edge_portals(State* s, Edge* e) {
    Weight* w = e.weight;
    return State__new(e.v, s.steps + w.len, 0);
}

fn path_length_portals(Map* m, Graph* g) {
    return path_length_internal(m, g, &cross_edge_portals);
}

fn cross_edge_nesting(State* s, Edge* e) {
    Weight* w = e.weight;
    if w.portal_dir == 0 {
        return State__new(e.v, s.steps + w.len, s.level);
    }
    int level = s.level + w.portal_dir;
    if level < 0 {
        return null;
    }
    return State__new(e.v, s.steps + w.len, level);
}

fn path_length_nesting(Map* m, Graph* g) {
    return path_length_internal(m, g, &cross_edge_nesting);
}

fn path_length_internal(Map* m, Graph* g, void* cross_edge) {
    Queue* q = Queue__new_owned(&free);
    q.push(State__new(m.start, 0, 0));
    HashMap* visited = HashMap__new(null, null);
    int len = -1;

    while q.size() > 0 {
        State* s = q.remove();
        if visited.put(s.pos + s.level * 0xffffffff, 1) != null {
            free(s);
            again;
        }
        if s.pos == m.goal { if s.level == 0 {
            len = s.steps;
            free(s);
            done;
        } }
        ArrayList* edges = g.out_edges(s.pos);
        int i = edges.size();
        while i > 0 {
            i = i - 1;
            Edge* e = edges.get(i);
            State* next = cross_edge(s, e);
            if next != null {
                q.push(next);
            }
        }
        free(s);
    }

    visited.drop();
    q.drop();
    return len;
}

fn graphviz(Map* m, Graph* g) {
    puts("strict graph {");
    printf("  graph [rank=source] { %d [shape=polygon style=filled fillcolor=%s] }\n", m.start, "lime");
    printf("  graph [rank=sink] { %d [shape=polygon style=filled fillcolor=%s] }\n", m.goal, "pink");
    puts("");
    Queue* q = Queue__new();
    q.push(m.start);
    # also start at every portal
    ArrayList* portals = m.portals;
    int i = 0;
    while i < portals.size() {
        Portal* p = portals.get(i);
        q.push(p.u());
        q.push(p.v());
        i = i + 1;
    }

    HashMap* visited = HashMap__new(null, null);
    while q.size() > 0 {
        int u = q.remove();
        if visited.put(u, u) != null { again; }
        ArrayList* edges = g.out_edges(u);
        i = edges.size();
        while i > 0 {
            i = i - 1;
            Edge* e = edges.get(i);
            q.push(e.v);
            printf("  %d [label=r%dc%d]\n", e.v, e.v / m.width + 1, e.v % m.width + 1);
            # only draw edges once
            if !visited.contains(e.v) {
                printf("  %d -- %d", u, e.v);
                Weight* w = e.weight;
                if w.portal_dir == 0 {
                    printf(" [label=%d]\n", w.len);
                } else {
                    # it's be easier to draw portals from the map directly, but
                    # do it from the graph, as that's where the data will be
                    # read from during the walk.
                    char* dir = "forward";
                    if w.portal_dir < 0 { dir = "back"; }
                    printf(" [label=%c%s : %d : %d%c penwidth=2 weight=0 color=red dir=%s]\n", '"', w.label, w.len, w.portal_dir, '"', dir);
                }
            }
        }
    }

    puts("}");
    visited.drop();
    q.drop();
}
