pub struct Instructions;
pub struct Ins;

pub struct Pt {
    int x,
    int y,
}

pub fn Pt_x(Pt* self) { return self.x; }
pub fn Pt_y(Pt* self) { return self.y; }

fn Pt__new(int x, int y) {
    Pt* p = malloc(sizeof(Pt));
    p.x = x;
    p.y = y;
    return p;
}

pub fn Pt_drop(Pt* self) {
    free(self);
}

fn Pt_equals(Pt* self, Pt* other) {
    return self.cmp(other) == 0;
}

pub fn Pt_hash(Pt* self) {
    return self.x ^ self.y;
}

pub fn Pt_cmp(Pt* self, Pt* other) {
    if other == null { return false; }
    int c = self.x - other.x;
    if c != 0 { return c; }
    return self.y - other.y;
}

pub fn Pt_clone(Pt* self) {
    return Pt__new(self.x, self.y);
}

fn Pt_into_delta(Pt* self, int dx, int dy) {
    Pt* p = Pt__new(self.x + dx, self.y + dy);
    self.drop();
    return p;
}

fn Pt_dx(Pt* self, int dx) {
    return Pt__new(self.x + dx, self.y);
}

fn Pt_dy(Pt* self, int dy) {
    return Pt__new(self.x, self.y + dy);
}

pub struct Points {
    Instructions* inss,
    Pt* curr,
    Pt* goal,
    int dx,
    int dy,
}

pub fn Points__new(Instructions* inss) {
    Points* ps = malloc(sizeof(Points));
    ps.inss = inss;
    ps.curr = Pt__new(0, 0);
    ps.goal = Pt__new(0, 0);
    return ps;
}

pub fn Points_drop(Points* self) {
    if self == null { return; }
    Instructions_drop(self.inss);
    Pt_drop(self.curr);
    Pt_drop(self.goal);
    free(self);
}

pub fn Points_next(Points* self) {
    if Pt_equals(self.curr, self.goal) {
        Ins* ins = Instructions_next(self.inss);
        if ins == null { return null; }
        Pt* next;
        if ins.dir() == 'U' {
            self.dx = 0;
            self.dy = 1;
            next = Pt_dy(self.curr, ins.len());
        } else if ins.dir() == 'R' {
            self.dx = 1;
            self.dy = 0;
            next = Pt_dx(self.curr, ins.len());
        } else if ins.dir() == 'D' {
            self.dx = 0;
            self.dy = -1;
            next = Pt_dy(self.curr, -ins.len());
        } else if ins.dir() == 'L' {
            self.dx = -1;
            self.dy = 0;
            next = Pt_dx(self.curr, -ins.len());
        } else {
            eprintf("Unknown direction '%c'\n", ins.dir());
            exit(1);
        }
        Pt_drop(self.goal);
        self.goal = next;
    }
    Pt* prev = self.curr;
    self.curr = prev.into_delta(self.dx, self.dy);
    return self.curr;
}
