pub fn main() {
    aocd_run(&solve);
}

fn solve(char** ans_a, char** ans_b) {
    Map* map = Map__from_input();
    int len = strlen(map.grid());
    printf("Map is %dx%d w/ %d grid elements!\n", map.width(), map.height(), len);

    int** adj = build_eight_way_adjacent(map.width(), map.height());
#    print_adjacent(adj);
#    drop_adjacent(adj);
#    map.drop();
#    return;

#    puts("Initial state:");
#    map.print();
    while map.ticks() < 10 {
#        printf("\nAfter %d minutes:\n", i);
        free(map.next_tick(next_grid(map.grid(), adj, len)));
#        map.print();
    }
#    map.print();
    printf("Resource value after %d minutes: %d\n", map.ticks(), map.resource_value());
    *ans_a = itoa(map.resource_value());

    # it started looking cyclic around 500, so get well beyond there
    while map.ticks() < 1000 {
        free(map.next_tick(next_grid(map.grid(), adj, len)));
    }
    printf("Resource value after %d minutes: %d\n", map.ticks(), map.resource_value());

    # find a cycle and measure its length
    int cycle_length = find_cycle_length(map, adj, len);
    printf("Cycle from %d, with length %d\n", map.ticks(), cycle_length);

    # advance the needed partial cycle for the target
    int target_minutes = 1000000000;
    int advance = (target_minutes - map.ticks()) % cycle_length;
    while advance > 0 {
        free(map.next_tick(next_grid(map.grid(), adj, len)));
        advance = advance - 1;
    }
    printf("Projected value after %d minutes: %d\n", target_minutes, map.resource_value());
    *ans_b = itoa(map.resource_value());

    drop_adjacent(adj);
    map.drop();
}

fn find_cycle_length(Map* map, int** adj, int len) {
    # Find a repeated map, and save its value and grid.
    int repeated_value = -1;
    char* repeated_grid = null;
    HashMap* history = HashMap__new_owned(null, null, null, &free);
    while true {
        int rv = map.resource_value();
        char* old_grid = map.next_tick(next_grid(map.grid(), adj, len));
        if history.contains(rv) {
            if strcmp(old_grid, history.get(rv)) == 0 {
                repeated_value = rv;
                repeated_grid = old_grid;
                done;
            }
        }
        free(history.put(rv, old_grid));
    }
    history.drop();

    # Measure the cycle length (didn't track it above...).
    int cycle_length = 0;
    while true {
        cycle_length = cycle_length + 1;
        if map.resource_value() == repeated_value {
            done;
        }
        free(map.next_tick(next_grid(map.grid(), adj, len)));
    }
    free(repeated_grid);

    return cycle_length;
}

fn next_grid(char* grid, int** adj, int len) {
    char* next = malloc(len + 1);
    int i = 0;
    while i < len {
        int* ns = adj[i];
        next[i] = next_char(grid, grid[i], ns);
        i = i + 1;
    }
    next[i] = null; # terminate the "string"
    return next;
}

fn next_char(char* grid, char curr, int* adj) {
    if curr == OPEN {
        if has_three(grid, adj, WOODS) { return WOODS; }
        return curr;
    }
    if curr == WOODS {
        if has_three(grid, adj, YARD) { return YARD; }
        return curr;
    }
    # must be a yard...
    bool yard = false;
    bool woods = false;
    int n = adj;
    while *n >= 0 {
        char c = grid[*n];
        n = n + sizeof(int);
        if c == YARD {
            if woods { return YARD; }
            yard = true;
        } else if c == WOODS {
            if yard { return YARD; }
            woods = true;
        }
    }
    return OPEN;
}

fn has_three(char* grid, int* adj, char target) {
    int hits = 0;
    int n = adj;
    while *n >= 0 {
        if (grid[*n] == target) {
            if hits == 2 {
                return true;
            }
            hits = hits + 1;
        }
        n = n + sizeof(int);
    }
    return false;
}
